
JS前置觀念

---語法糖---:
語法糖只是讓程式碼看起來更簡潔，與原先並不會有使用上的差異。
在物件使用屬性都需要加分號:
但在ES6以後
若是function則直接輸入function的呈述式即可
範例:
let d ='d'
let obj = {
    a:'a',
    fn(){
        console.log('i')
    },
    b:'b',
    d,
}

除了function外，物件也可以直接代入，那麼屬性名稱就等於變數名稱，屬性值等於變數值

陣列串接---
以往來說會是 c = a陣列.concat(b陣列)
但ES6可以使用更省事的方法

C陣列 =[...a陣列,...b陣列]//...的方法是將陣列內的物件取出並排列
若沒有使用...的話，c陣列會是包住a陣列及b陣列

同時物件也可以用此方法新增

let a = {
    a:'a',
    b:'b',
}

let c ={
    ...a
}

//類陣列轉為純陣列也可以使用相同方法


---預設值---
現在參數也可以帶入預設值，假設今天有兩個參數，但使用者只代入一個那很有可能會出現bug
let fn = (a,b)=>{
    return a + b
};

fn(1,2) //3
fn(1) //NaN

傳統的方法避免的方法是
let fn = (a,b)=>{
    if(!b){b=2}
    return a + b
};

現在只需要使用預設值就可以避免錯誤

let fn = (a,b = 2)=>{
    return a + b
};


---this指向---

simple call

範例:
var someone = '全域';
function callsomeone(){
    console.log(this.someone);
};

callsomeone();//這個就叫做simple call 當前面沒有任何物件，就叫做simple call 又稱為簡易呼叫

而this的指向跟怎麼定義它沒有關聯而是呼叫的方法。假設使用simple call 就是呼叫全域
但若是使用object.callsomeone(),那就會指向前面的object內的內容。


var obj = {
    someone:'物件',
    callsomeone //將上面宣告的函式放進來
};

obj.callsomeone()//顯示物件


物件內的物件呼叫

var obj2 = {
    someone:'物件外',
    callsomeone //將上面宣告的函式放進來
    obj = {
        someone:'物件內',
        callsomeone //將上面宣告的函式放進來
    };
};

obj2.obj.callsomeone()//顯示物件內


常見陷阱


var obj = {
    someone:'物件',
    fn(){
        callsomeone();//它其實也算simple call 但平常並不會這樣使用
        //注意這裡，callsomeone前面並沒有任何物件
    }
};

obj.fn()//顯示全域


var obj = {
    someone:'物件4',
    fn(){
        setTimeout(()=>{
            console.log(this.someone)
        });
    },
};

obj.fn()//顯示全域 原因是setTimeout是在全域下執行而非object

補充:若是在事件觸發後，this通常代表觸發的元素本身
總結:this的指向跟調用(呼叫)的方法有關



---箭頭函式---

特點:除了語法糖外，特點就是它沒有自己的this
範例:
let obj = {
    callName:function(){
        console.log(this);//顯示物件本身
        setTimeout(()=>{
            console.log(this)//在傳統函式中會指向window，但若是使用箭頭函式則會跟著父層指向相同，在這個範例中也就是指向物件。
        }),
    }
}

obj.callName();


常見陷阱
let name = 全域;
let obj = {
    name:'小明',
    callName:()=>{
        console.log(name);
    }
}

obj.callName()//顯示全域。與傳統函式不同，前面說到箭頭函式會跟著父層指向相同。但在這個範例中obj內的callname外層並沒有函式，準確地來說它的外層函式就是全域，所以這個this就指向全域。


let name = 全域;
let obj = {
    name:'小明',
    callMe(){
        let callName = ()=>{
            console.log(this.name);
        };
        callName();
    },
};

obj.callMe()//顯示小明 因為在callname外層的函式是傳統函式，也就是指向物件本身，而箭頭函式則是跟隨外層函式來定義this。理所當然地也就跟著callMe的this定義。




---元件結構(關注點分離/MVVM)---
所謂元件結構就是將一個功能所運用到的所有內容都放在一個物件中，包含函式、儲存的資料等
依所需情況調用及觸發，每一個屬性都各自獨立但卻又相關，所以稱為關注點分離。
基本的元件結構有:
1.資料
2.方法、觸發器
3.生命週期


const click ={
    data:[],
    function(){

    },//若是要渲染HTML結構，盡量在一個function內
    init(){//稱為生命週期，一開始載入後所要執行的函式
        this.function
    }
}


範例:
const click ={
    data:[],
    fn(){
        console.log('安安你好')
    },
    init(){//稱為生命週期，一開始載入後所要執行的函式，通常是開發者自訂義
        this.fn();
    },
}
click.init()


---物件、陣列、函式傳參考---

在我們創立一個物件的時候，其實並非是像純值(如字串、布林)一樣將值賦予到變數上，而是將物件的位置傳給變數。

當我們新增一個物件就相當於在網頁的儲存區建立物件。而當我們要取用物件時就會自動導向物件的路徑。
好比賦予變數物件，讓我們從以下範例解釋。

let a = {x:1};
//在這操作中瀏覽器共做了兩件事
1.在瀏覽器的儲存區中新增{x:1}的物件
2.將儲存區的物件路徑賦予到a

所以當我們使用console.log(a)時，其實是從a這個路徑瀏覽{x:1}這個物件。
由此可知，當我們同時賦予兩個變數一樣的物件時，他們的路徑都是一樣的，其中一個物件屬性及值更動，另一個也會同步。

let a= {x:1};

let b = a;

b.x = '2';

console.log(a.x)//顯示2

須知注意:
但是我們得注意，當我們又新增了一個{}時，就等同於又新增了一個路徑，就算裡面內容相同也並非是同一個路徑。
範例:

let a = {x:1};

let b = {x:1};

console.log(a===b)//回傳false


淺深層複製

當我們要複製物件內容但又不共用同一個參考路徑時該怎麼做呢?
有兩個方法，淺層及深層。

淺層:
淺層就是複製物件內的值與屬性，但屬性的值內若有物件，那這個物件還是共用同個路徑的。
let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = Object.assign({},a);//方法一
let c = {...a}//方法二

//按照上面的範例來說，a跟b還是共用同一個x物件路徑


深層:
深層拷貝就不會有共用路徑的問題，而是會創造一個新的物件
原理很簡單，就是將物件內的所有內容都轉為字串，再從字串轉為物件。


let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = JSON.parse(JSON.stringify(a));



promise

promise 嚴格來說是為了解決非同步語法難以建構以及管理的問題。
簡單來說就是在所有資料都處理好以後，再接續執行下一步。
常用於AJAX，當處理完所有傳送及取得的程序以後，再來接續進行下一步的渲染等動作。
經典使用promise的AJAX處理套件為axios

promise會先建立一個建構式

const promise_Set = (status)=>{//套入狀態
    return new Promise(resolve,reject)=>{
        setTimeout(()=>{//讓此程式碼最後執行
            if(status){//當狀態為true時
                resolve('成功')//resolve的參數代入成功
            }else{
                reject('失敗')//reject的參數代入失敗
            }
        })
    }
}

promise_Set(true);//狀態套入
    .then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
    })
    .catch((rej)=>{
        console.log(rej)//同上會是reject的('失敗')
    })


promise串接
promise_Set(true)
.then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
        return promise_Set(true)//當在此使用return時，下一個.then/.catch就會是此promise_Set(true)所回傳的結果
    })
.then((res)=>{
    console.log(res);
})

元件中使用promise

const a = {
    data:{}
    init(){//這邊若是要用this需要使用傳統函式，因為箭頭函式this是隨著父層函式的this而定義
        promise_Set(true)
        .then(res=>{
            this.data.res = res;//在data元件中新增res的屬性及值
        })
        .catch((rej)=>{
            alert('傳送失敗');
        })
    }
}

a.init();



使用axios搭配promise

axios.get('url')//url代表連接網址
    .then((res)=>{
        console.log(res)//res回傳的資料
    }) //axios內建就有promise所以可以不用建構直接使用
    .catch((rej)=>{
        console.log(rej.response)//回傳失敗的資料
        console.log('串接失敗')
    })

post方法補充: axios.post('url',{傳送的內容});



---ES模組---

ES步驟:

1.於模組化的script上加上type="module"

2.匯出匯入觀念
匯入跟匯出有很大的關連，所以我們先說明匯出。

匯出(js)//僅在js進行

匯出又分成預設跟具名匯出

預設匯出: export default
//每個檔案只能有一個


具名匯出: export const xxx = ...
//每個檔案有多個
而匯出可以同時匯出具名及預設



匯入(html,js)//在html or js進行
既然有預設匯出，自然也又預設匯入及具名匯入

預設匯入 import 自訂名稱 from 檔案

具名匯入{具名名稱} from 檔案


匯出入方法

匯出用法
1.新建個匯出JS檔案

2.填上匯出程式碼
export default {//默認
    ...程式碼
}

export const abc{//具名
    ...程式碼
}

匯入用法

1.在要匯入的檔案中導入

import fn from './...路徑'//默認

import{abc} from './all.js'


此時fn就等於你寫在匯入JS檔案內的那一個function or obj or ary or 變數

2.使用
接下來就看你是匯入甚麼，就照原先的方法使用即可。



匯入有兩種方式:
單一匯入、全部匯入

比較建議單一匯入，因為全部匯入錯誤難以發現
單一匯入就是個別匯入
全部顧名思義就是不管有多少個匯出，一次接受一次匯入


單一:

inport {a,b} from '路徑'
//匯入a及b匯出


全部:

import * as all from '路徑'
//as 是賦予到一個變數的名稱上 all就是那個物件的名稱


sideEffect.js(沒有包含匯出的檔案):
也就是沒有使用export的內容，其實也可以進行匯入

inport '路徑' //直接導入即可



實戰:

先說明每一個 type="module"的作用域是各自獨立的。
也就是說假設有兩個script都有綁type="module"並且有匯入。
但我在第一個匯入的檔案，在第二個是無法使用的


ESM
網路上找的到的CDN的網址上若有ESM字樣基本上都可以使用import的方式匯入

inport {} from 'CDN網址'

直接使用




觀念都理解了，正式進入vue的教學。

首先vue的概念就是對應元件結構
{
    data:[儲存的資料]
    render()//渲染HTML的function(事件觸發)
    init()//載入時所執行的動作(生命週期)
    //假設今天要使用這個元件結構，就從呼喊init這個function就會執行。
}

只是vue都幫你把以上的事情都做好了，基本上只需要在指定標籤加上指定屬性，vue就會幫你做渲染


vue 環境設置
於瀏覽器安裝vue開發者工具套件
網址:https://headwayapp.co/vue-js-devtools-changelog/timeline-and-api-166716
//注意一定要從這安裝beta版本，可能是設定問題正式版沒辦法使用。

在開發者工具中可以找到vue的介面
    介面左邊會有一個根元件，點選，右邊會有data的資料庫。
    後面開發的話都會以這個根元件為主，階梯式的呈現在介面上

載入vue cdn放在head內 //這邊要注意版本，目前教學為3

<script src="https://unpkg.com/vue@next"></script>



---第一課定義元件---
型態:
Vue.createApp({//定義元件 也就是vue的起手式，類似jq的$(doc).ready

  data(){
    return{
      //資料庫
    }
  }
}).mount('DOM')// 執行元件    
//這邊的mount是將這個元件給綁定到指定的DOM


範例及解說:
Vue.createApp({//使用vue時都會先使用createApp，上面有提到類似JQ的ready
  data() {//定義一個資料儲存區 需注意的點是這邊的data是一個函式，資料是用return的方式回傳。這個作法的用意是使用原生JS內件的proxy功能，讓物件內的其他函式可以使用this.屬性調用
    return {
      counter: 0,
      text: '這裡有一段文字123'
    }
  }
}).mount('#app')//到mount之前，元件及資料儲存的定義就已經完成，mount則是綁定DOM


---第二課完整vue定義及事件--- 

型態說明:

<div> {{value}} </div>//顯示123 這邊是輸入資料路徑。
簡單的說明一下資料路徑
當我們需要調用data()這個資料庫內的路徑時，data所回傳的就是一個物件，並不需要使用data.value的方式呼叫，因為當data()將{}回傳時，{}就已經是app這個物件內的值了。
總得來說就是只需要使用要調用時只需要使用return{}物件內的值就可以了。
假設你物件內的值是物件，你要取用物件內的物件，就使用原生js的物件呼叫方法即可。


<input type="buttom" v-on:click="click"> //當DOM要觸發methods裡面的方法時，於標籤內輸入v-on:觸發事件="function" ex.這邊不需要再加個中括號了()

const app = {
    data(){//資料儲存區 ex.這邊一定要是函式
        return{
            value:'123'//通過{{屬性}}，可以將值給渲染到瀏覽器上
        }
    }
    created(){生命週期 更改data內容
        this.value = '456'//這邊之所以抓地到data的值是因為使用了return，return後的內容就會被proxy攔截。簡單來說就是return後內容父層抓地到
    }
    methods:{//方法(事件觸發) ex.會是一個物件

        click(){
            console.log('安安');
        }        
    }
}

事件型態:
HTML
<div v-on:事件="function名稱">按鈕</div>
//因為已經綁定在區塊中了，所以不需要再使用物件方法呼叫
methods.click (X)
click (O)//不需要加入()

補充:v-on事件有:
click 觸發
keyup 鍵盤  keyup這邊比較特殊,因為鍵盤有多個按鍵，所以keyup的v-on型態是這樣: v-on:keyup.enter ="function"
//其中enter為按鍵的縮寫，只要是按下enter都會觸發。
//縮寫類型有 .enter, .tab, .delete(包含刪除跟退格鍵), .esc, .space, .up, .down, .left(滑鼠左鍵), .right(滑鼠右鍵)
//按鍵縮寫好像也能直接輸入key代碼(待確認) 
input 只要input的值有改變就會觸發 與原生用法差不多(change,input)


第三課 雙向綁定

v-model 綁定到資料輸入區並與其同步，只要資料輸入區改變or v-model的內容改變，兩者都會同步 (綁定一)

當定義一個元件以後，若是要將input取得的資料輸入進資料庫需要使用v-model
相當於原生.value /JQ.val()的概念。
//亦可取得select的value

型態:
HTML
<input v-model="資料庫物件名稱.屬性名稱">//已經綁定在區塊內，所以就直接使用資料路徑即可



v-bind: 綁定輸出到HTML屬性上 (綁定二)
v-bind可以資料酷的輸出到指定的HTML屬性上
型態:
HTML
<img bind:src="資料庫名稱.屬性名稱"

稱為雙向綁定的原因是兩者已經同步，當有一方改變，另一方也會同步改變。



第四課 導入外部資料進資料區

說明:

let obj = {//外部資料 不管外部資料是甚麼形式。陣列 or 物件等都一樣可以導入
    a:123,

}

const = add{
    data(){
        return{
            data:{
                
            }
        }
    },
    created(){//當我們要使用外部資料進行渲染時，就在生命週期這邊導入外部資料，這邊在一開始載入vue的時候就會執行
        this.data = obj//如此在載入vue時，外部的資料就會導入到指定的路徑
        //這邊要注意this本身就已經代表data，所以這個data是return物件內的data屬性喔
    }
    method:{

    }
}

Vue.createApp(add).mount('#id')

---第五課 將資料傳入資料庫---
因為v-model的特性是雙向綁定，所以假設我們每一次觸發事件都要新增一筆不一樣的資料要怎麼處理呢?
範例解說如下:

 <div id="app">
        帳號:
        <input type="text" v-model="temp.account">
        <!-- v-model有個特點 假設指定路徑內沒有該屬性，那會自動新增這個屬性 -->
        <br>
        密碼:
        <input type="text" v-model="temp.password">
        <br>
        <button type="button" v-on:click="add_userdata">送出</button>
        <!-- 這邊type要使用button 否則預設定義是submit -->
        導入的帳密:{{temp.account}},{{temp.password}}
        <br>
        userdata內容:{{userdata}}
    </div>
    <script>
       Vue.createApp({
            data(){
                return{
                    userdata:[],
                    temp:{}
                }
            },
            created(){
                this.userdata = JSON.parse(localStorage.getItem('user'));//從local端取得資料
            },
            methods:{
                add_userdata(){
                    this.temp.id = new Date().getTime();//此行目的產生唯一性id 從這邊也可以有v-model的特效，物件內沒該屬性會自動新增 就跟原生JS一樣
                    this.userdata.push(this.temp);//將目前temp的內容上傳至userdata這個陣列內
                    this.temp = {};//清空
                    this.update();//輸入至local端
                },
                update(){
                    // localStorage.setItem('user',JSON.stringify(this.userdata))
                    localStorage.setItem('user',JSON.stringify(this.userdata))
                }
            },
        }).mount('#app');
        //順便提一下原生的方法 取得DOM.value > 輸入資料庫and localstorage > 用innerHTML渲染網頁 
    </script>


---第五課使用v-for將多筆資料渲染到網頁---

v-for這個屬性的功能類似使用for迴圈累積文字並渲染到網頁上，只是這個操作更直覺簡潔。
型態:
指定DOM上 v-for="自訂義名稱 in 資料路徑(陣列或物件)"
//這個就類似for in的方法 但還是有些不同
//v-for的原理是這樣的，它會掃過資料路徑的物件或陣列
//接著使用者就可以使用{{自訂義名稱.屬性}}(自訂義名稱代表物件或陣列內的值)將內容給呈現到畫面上
//使用者這邊只要輸入一次即可，當你在HTML的標籤上輸入一次{{}}，就會自動將資料路徑內的所有值都呈現在畫面上


多說無益，直接看範例:

先看script code
  <ul id="app">
        <li>
            <img src="./根元件.png" alt="" style="width: 50px;border: 1px solid;">
            <p>商品一</p>
        </li>
        <li v-for="i in products" :key="i.id" >
            <!-- 
                型態:v-for="自訂義名稱 in 資料路徑(物件/陣列) v-for會自動讀取指定路徑的所有內容"
                接著v-for要放到想要複製的區塊上，只要放上來子DOM也會一同執行for
                這邊補充key用意，是要讓每個渲染出來的區塊有唯一性，方便之後操作
            -->
            <img v-bind:src="i.url" alt="商品圖" style="width: 50px;border: 1px solid;">
            <!-- 因為會v-for會一一的複製指定DOM，所以子內容的v-bind也會跟著一一改變跟渲染 -->
            <p>{{i.name}}</p>
            <!-- 文字同上說明 -->
        </li>
    </ul>

    <script>
      
        const products = [//導入的資料
            {
                id:'1',
                name:'商品二',
                url:'https://chiyum.github.io/myPage/img/formalLogoNb.png'
            },
            {
                id:'2',
                name:'商品三',
                url:'https://chiyum.github.io/holdkibor/img/logo.png'
            },
        ];

        Vue.createApp({
            data(){
                return{
                    products:[],//先建立個空物件，等啟動後導入資料
                };
            },
            created(){
                this.products = products;//載入時導入外部資料
            },
            method:{

            }
        }).mount('#app');//綁定區塊

        //輸入完往HTML繼續

    </script>


補充:會使用key="iteam.id"是要補上唯一值，這在後面章節會介紹。


---v-if--- 

今天可以使用狀態來決定是否要顯示視窗

  Vue.createApp({
            data(){
                return{
                    products:[],//先建立個空物件，等啟動後導入資料
                    isShow:false
                };
            },
            created(){
                this.products = products;//載入時導入外部資料
            },
            method:{
                show(){
                    this.isShow = true;
                }
            }
        }).mount('#app');//綁定區塊


<button type="button" v-on:click="show">按鈕</buttom>

<ul v-if="isShow">//若isShow為true就會顯示，反之。
</ul>


ex.v-if="選項一||選項二" 可以使用邏輯運算子，以上述範例，其中一個選項回傳true，那if就會顯現

ex2.跟v-if很像的有v-bind:class=""
除了可以將要裝上的class貼上外，還可以使用狀態判斷的方法來決定是否要添加class
v-bind:class="{class名稱:路徑狀態}"//若路徑狀態回傳為false則不開啟，反之true則開啟class



---vue指令(directive)---
    所謂指令就是v-if, v-model, {{}}等這些操作被稱為指令


    指令又分為三個部分: 資料相關、渲染方法、事件綁定

    1.資料相關:就是會操作到資料區塊的指令，如v-model

    2.渲染方法:顧名思義就是渲染網頁相關，例如v-if, v-for, v-show

    3.事件綁定: v-on @...等這些事件綁定的操作

    雖然前面已經介紹過部分的操作了，但只不過是大略介紹，以下將會進行詳解。


ol.v-text and {{}}(Mastache)

    v-text 與{{}}其實是一樣的效果
    差別在於v-text是在指定標籤上渲染文字

    {{}}則是在{{}}在哪，就在哪裡渲染


    一般實戰來說用到{{}}的機率更多
    但v-text有個好處就是可以隨著依附的標籤進行css的更動
    範例:
    <em v-text="name"></em>//如此v-text渲染出來的文字就會是em自帶的斜體

ol.v-html 

    基本上與原生的innerHTML標籤是一樣的，給予標籤的字串後會自動判別標籤並將標籤轉為dom
    範例:

    data(){
        return{
            name:<p>測試文字</p>
        }
    }

    <div v-html="name"><div>//之後就會產生一個p標籤及"測試文字"的字串

    不過基本上是不建議使用這個方式，因為會有XSS攻擊

ol.v-once 單次渲染
    當我們只想要讓網頁在一開始的時候渲染，之後資料更動時不會跟著更動的話就可以使用v-once
    範例:
    <p v-once> {{ name }} <p>// v-once只需這樣寫在標籤上即可 如此不管後面資料怎麼變動，在標籤內的資料只會受到第一次渲染的影響，後續都不會再改變

    進階使用:

        樣板字面值:
            在{{}}中其實可以使用js的樣板字面值，與JS內運用完全一樣，只需要在{{}}加入``即可
            範例:
            {{`你好安安`}}//這樣的話並不會發生顯示{{`你好安安`}}的錯誤，而是會渲染你好安安這個純字串
            {{ `${name}對我說你好` }}//當然也可以插入變數，但是注意，${}內只能插入vue內的資料，在外部的資料是無法讀取的，會顯示undefind

        表達式:
            {{ name.toUpperCase() }}//亦可直接在{{}}內進行表達式 toUpperCase()的用法是原生JS 目的是將字串轉為大寫
            {{ `題目:1 + 1 = ` 1+1   }}//可以直接在{{}}內進行JS的運算 也是表達式的一種
            {{ isOpen?'早安': '午安' }}//更可以使用三元運算子

        呼叫函式:
            {{ say() }}//既然都可以使用表達式了，呼叫使用function當然也不再話下 這邊注意，不需要像外面呼叫一樣使用this，直接使用function即可

        顯示{{}}:
            假設說想要顯示{{}}，而不是要使用顯示資料的功能。那就在{{}}的標籤加入v-pre即可
            範例:
            <p v-pre>{{ name }}</p>  //會顯示{{ name }}



ol.v-for
    v-for 可以用於物件or陣列，會掃過陣列、物件的所有值
    型態:v-for = "自訂義名稱 in 指定陣列or物件"
    此時的自訂義名稱就是每次跑過的值，假設今天有個範例是這樣的:


        let test = [
            {
                name:'小明'
            },
            {
                name:'杰倫'
            },
        ]

        <li v-for="iteam in test">
            {{ iteam.name }}//iteam就是每次跑過的物件，name就是每次跑過物件的屬性
        </li>

        除此之外，v-for在自訂義名稱還有個索引值 索引值就是陣列or物件的值的位置順序
        類似forEach(data,i){}其中data是內容，i是索引值
        型態:v-for = "(自訂義名稱,自訂義索引值) in 指定陣列or物件"
        按照上面的範例:


        <li v-for="(iteam,key) in test">
            {{key}} / {{ iteam.name }} //以第一個小明的物件來說明，小明所在的這個物件的索引值就是test[0];
        </li>

        注意事項:若今天是以物件跑回圈，那麼key會是屬性名稱。同樣以小明來說明，key就是name


    純數值迴圈:

        v-for除了帶陣列物件外，還可以使用數字
        型態:v-for = "自訂義名稱 in 數字"
        那麼自訂義名稱就會是數字1開頭一直跑到指定數字(含)結束
        範例:
         <li v-for="iteam in 5">
            {{ iteam }} //那麼iteam就會從1跑到5
        </li>

        觀念:
        每個v-for擁有同個父元素時，子元素必須要有獨特的key，重複的key會造成渲染錯誤
        甚麼叫渲染錯誤?而且可能會有人疑惑可是當沒有加上key時他還是照原本的順序跑耶，這個渲染錯誤是偶爾才會出現的bug嗎?

        其實不是。拿上面的例子來說:

        <li v-for="(iteam,key) in test">
            {{ iteam.name }} 
            <input type="text">//假設今天我在這邊輸入1234的字串
        </li>
        然後我再改變test的順序，讓小明在後
        那麼就算小明的文字被渲染到杰倫底下了，這個我輸入1234的字串依然會在原地。
        這說明甚麼?說明只是資料的順序調換了，網頁並沒有重新渲染，這個就是所謂的渲染錯誤。
        而為了讓input是綁定資料的就需要加上個key
        那key是甚麼?有人會是使用gettiem在原先的物件內創造個獨一無二的數字id，有人則是會用原本屬性就有的值，如小明跟杰倫就是不同的值
        這兩者都可以，只是要記住一點，這個值是得獨一無二的，若是有多個小明，那key就會重複。

        正確的輸入key:

        <li v-for="iteam in test" v-bind:key="iteam.name">
            {{ iteam.name }} 
            <input type="text">//假設今天我在這邊輸入1234的字串
        </li>


        v-for + template
        有時候會遇到一個狀況，我們需要在兩個不同的節點加入一筆資料，那該怎麼做?

        狀況範例:
        <table>
            <tr>
                <th rowspan="2">1</th>
                <td colspan="2">
                飯糰
                </td>
            </tr>
            <tr>
                <td>30</td>
            </tr>
        </table>

        可以看到2個tr為不同節點，若要在td內輸出資料，v-for好像沒辦法使用
        那此時就可使用template這個標籤:

         <table>
            <template v-for="iteam in test">
                <tr>
                    <th rowspan="2">1</th>
                    <td colspan="2">
                    {{iteam.name}}
                    </td>
                </tr>
                <tr>
                    <td>{{iteam.money}}</td>
                </tr>
            </template>
        </table>

        如此父元素就會是template而非tr了
 



ol.v-if渲染判斷

    當我們渲染時是要有條件地進行渲染時，就需要用上v-if
    甚麼叫有條件?假設我今天要使用者點擊才會出現這就叫做有條件

    型態:<p v-if="屬性路徑"></p>
    //只要屬性路徑為true就會顯示，反之false則是消失 !!注意這邊是消失，這邊與v-bind:class{class:屬性路徑}的差別在於屬性路徑我們是設定class 而class只有隱藏並沒有消失
    
    v-if對應的是v-else。都有if了，沒else說不過去吧?
    v-else的邏輯與JS一樣，當if為false，那麼就渲染v-else

    範例:

    <p v-if="false">早安</p>
    <p v-else>午安</p>

    v-else-if
    看到這裡想必大家都知道還遺漏個else if。以下介紹個用法:

    Vue.createApp({
        data(){
            return{
                link:'小明'
            }
        }
    })

    <button type="button" v-on:click="link = '小明' "> 小明 </button>
    <button type="button" v-on:click="link = '小美' "> 小美 </button>
    <button type="button" v-on:click="link = '小如' "> 小如 </button>//這邊可以注意一下，v-on也可以這樣用，可以直接更改data的值。只要從HTML指定的話，都不需要加this
    
    <div v-if="link == '小明' ">小明吃牛排</div>//這邊可以看到，我們並非需要調動到data的資料，只需要回傳false or true的布林就可以操控v-if
    <div v-else-if="link == '小美' ">小美吃乾麵</div>
    <div v-else>小如吃漢堡</div>

    備註:v-if 跟v-for 不推薦一起使用在同一個標籤上 可能會造成一些錯誤 主要是因為v-if的權重比v-for更高
    若有這個需求可以搭配template 讓template跑for,if用於要隱藏的元素
    
    v-show
    v-if跟v-show放在同一章解說是因為兩者差異不多，差別在於v-show若為false 則是用dispaly:none。與v-if是直接刪除節點差別在此


ol.v-bind 屬性
    v-bind可以將資料輸入到屬性中。如src, data-*, class, id等 基本上所有的HTML標籤都可以套用
    型態:v-bind:屬性="屬性路徑"
    簡寫模式: :屬性 //簡寫模式很簡單，直接去除v-bind即可

    v-bind同樣也可以搭配v-for使用

    v-bind亦可動態的加入屬性

    <input type="text" :[type]]>
    <input type="button" value="切換" v-on:click=" type = type === 'disabled' ? 'readonly':'disabled' " v:bind:disabled="true or flase">//除了資料路徑外，還可以使用表達式 布林值來決定屬性是否存在
    //這段v-on的邏輯是 資料路徑(type)的值 = 如果資料路徑(type) === disabled的話返回readonly給資料路徑，否則返回disabled給資料路徑
    //首先 判斷右邊type這個資料值是否為disabled，是的話就返回readonly回來，否的話就返回disabled
    //接著返回到右邊type的值再賦予給type
    //為甚麼不使用一個type就好了呢?type === 'disabled' 是在比對而已，後面的三元運算子雖然會回傳，但並不會回傳在type上
    //所以前面多一個 = 是為了要將回傳的值賦予到type上面

    備註:disabled是禁用input, readonly則是只能讀不能寫
    



ol.樣式切換 v-bind:class運用
    最基本的使用方式有兩種:


    data(){
        return{
            class:'className',//這邊class以字串型式
            isShow:false,//這個屬性(key)的值為布林值
        }
    }

    1.搭配資料庫給予class
    範例:
    <p v-bind:class="class"></p>//這邊class為資料庫中的路徑
    如此當vue渲染這個標籤時就會套用指定路徑的class

    2.依照布林值選擇觸發與否
    範例:
    <p v-bind:class="{className:isShow}"></p>
    //這邊className則是class的名稱 isShow則是布林值
    //因為我isShow是true所以會套用這個class
    //ex.className就是屬性(key),值是布林值但也可以使用判斷式
    //這邊須注意，這邊的className是不能從資料庫取得的，只能輸入你所命名的class名稱

        進階使用:
        上面的介紹是使用物件方式來選擇是否套用class，但其實也有陣列的方式。
        不過物件方式還沒完全介紹完，這邊先介紹物件的部分。
        
            套用多個class:
            既然是物件了，那當然可以擁有多個key與值
            範例:
            <p v-bind:class="{className:isShow,className2:isShow2}"></p>
            //兩個class可以同時使用同個布林值路徑也可以不同。


        className若有 "-"這個文字:

        我們在:class套入class名稱的時候，class是不可以有-這個名稱的。
        這是因為我們套入的是物件，若要解決這個方式就是將key值變為字串就可以到解決。
        範例:
         <p v-bind:class="{'class-Name':isShow}"></p> 


        多個class放在同一個物件中:
        當你有多個class想要放在同一個標籤，卻又覺得在標籤內的屬性太長了怎麼辦?
        這時就可以將class給套入物件中

        data(){
            return{
                objClass:{
                    'class-Name':true,//無法使用資料路徑的布林值
                    className:fasle,//但可以直接輸入判斷式，若有需求就直接在mathods使用this.objClass.className = false or true 改變即可
                }
            }
            change(){
                this.data.box = this.data.box ? false : true;//這邊使用toggle的方式
            }
        }

        <p v-bind:class="objClass"></p>//直接將物件名稱帶進來即可 


        陣列寫法:
        如果說物件方式是使用判斷式來選擇是否要套用class，那陣列方式就是可以選擇套用多個class
        範例:
        <p v-bind:class="[className,className2,className3]"></p>//這邊className就是你所命名的class名稱
        效果就跟原生的class="className className2 className3"是一樣的效果
        當然也可以使用在data資料庫中寫好陣列並直接將陣列路徑套用到:class=""中即可。
        //這邊與物件一樣，差別在物件形式與陣列形式而已，就不做示範。


        操作行內樣式(style):
        操作style跟class的方式其實觀念是差不多的，只有操作上有些許差異
        操作方式有三種:

        
        1.在標籤上撰寫:
        上面所說過因為我們套入的是物件，所以不能有"-"這個符號，所以我們在寫style時，若原先的css文字中有"-"。
        那麼我們必須使用小駝峰的方式撰寫。
        甚麼是小駝峰?拿background-color來說，就是抽掉"-"，並在原先-後的第一個英文數字改成大寫
        background-color = backgroundColor 
        範例:
        <p v-bind:style="{backgroundColor:'red'}"></p>//記得這邊值是字串
        //key是代入style的屬性:值是代入相對應的值


        2.從資料取得物件
        style同樣可以從資料路徑中取得，在資料路徑中使用key與值的方式與在標籤上撰寫是一樣的，必須使用小駝峰形式
        範例:
        data(){
            return{
                objStyle:{
                    backgroundColor:'red',
                    fontSize:'12px'
                },
            };
        },


        <p v-bind:style="objStyle"></p>//記得這邊值是字串

        3.陣列方式撰寫style:
        其實使用陣列方式撰寫style，就是將上面撰寫的物件方式給加到陣列內套用而已
        範例:
        <p v-bind:style="[objStyle,{backgroundColor:'black',},objStyle2]"></p>//記得這邊值是字串

        補充:在key值也可以插入資料例如{paddingLeft: 資料路徑 + 'px'}


ol.資料綁定v-model 與表單:
    v-model在對應每個input type所產生的效果是不一樣的，以下我們來一一介紹:
    
    1.type="text"類型 不管是password 還是search類型，只要是與text相同的都是這個種類:
        這類綁定v-model的話，不管是資料庫還是標籤兩邊的資料更動是同步的
        範例:
        data(){
            return{
                text:'',
                checkbox:false,
                checkbox2:''
            }
        }

        <input type="text" v-model="text">
        //如此只要input輸入文字，資料庫那邊也會更新。
        //若資料庫刪除文字，input也會跟著刪除。

    2.綁定到checkbox(複選框)時:
        如果是綁定單一(單選)checkbox的話，當使用者點選時會回傳true，反之則是false


        <input type="checkbox" v-model="checkbox">//套用上面的data資料庫

        <p>{{ checkbox ? 答對了: 答錯了 }}</p>//通過三元運算子呈現不同的字串內容

    3.checkbox單選延伸:
        如同上面的結果，除了使用三元運算子以外，還有另一種用法
        
        
        <input type="checkbox" v-model="checkbox2" true-value="答對了"  false-value="答錯了">邏輯是這樣的，當checkbox回傳true時，回傳給資料庫checkbox2的值是true-value的內容，反之。

        <p>{{ checkbox2}}</p>//通過三元運算子呈現不同的字串內容


    4.checkbox複選使用:
        checkbox複選框的使用就需要使用到value這個屬性
        以下以範例來說明:

        data(){
            return{
                chose_ary:[],//複選使用是綁定到到陣列
            }
        }

        <input type="checkbox" value="標籤一" v-model="chose_ary">
        <input type="checkbox" value="標籤二" v-model="chose_ary">
        <input type="checkbox" value="標籤三" v-model="chose_ary">
        //三個是綁定同一個陣列，所以選擇以後value會加入陣列內

        {{ chose_ary.join(' ') }}//讓chose_ary每個值的間隔加入空白並渲染


    5.radio 單選框
        checkbox與radio差別在於radio只能選擇一個，當你的v-model綁定同一個資料路徑時，選擇其中一個選項，另一個就會取消選擇
        所以回傳到資料的值只會有一個，我們直接看範例:

        data(){
            return{
                chose:'',//value為字串
            }
        }

        <input type="checkbox" value="標籤一" v-model="chose">//這邊value不需要用v-bind
        <input type="checkbox" value="標籤二" v-model="chose">
        <input type="checkbox" value="標籤三" v-model="chose">
        //三個綁定同一個資料路徑

        {{ chose }}//當我選擇標籤一，那其他被選擇的選項就會消失。接著當我在選擇標籤二，那原本選擇的標籤一會在消失，chose的值會改為標籤二

    6.select 單選
        select雖底下有很多的option，但v-model是綁在select上的。
        接著每個option都有各自的value。
        當select選擇option時，value會傳到資料庫中
        範例:

            data(){
                return{
                    chose:'',//value為字串
                }
            }

            <select v-model="chose">
                <option value="三民區s">三民區</option>
                <option value="小港區s">小港區</option>
                <option value="琴雅區s">琴雅區</option>
            </select>

            //當使用者點選三民區時，value三民區s會傳送到chose內
        
        select搭配v-for:

            data(){
                return{
                    data:[
                        {
                            name:'小明'
                        },
                        {
                            name:'杰倫'
                        },
                    ]
                }
            }

            <select v-model="chose">
                <option v-for="iteam in data" :key="iteam.name" :value="iteam.name">{{ iteam.name }}</option>//這邊注意若是沒有加上value，那麼回傳的值會是option內的文字。
            </select>
        
        補充:在select使用v-model時，因為資料原先是空字串，所以若是不選擇時。預設的select是空值。若是要顯示預設文字，那就新增一筆option標籤 並新增value的屬性
        //注意這邊的value是原生而非v-bind的
        //同時若是這個預設文字只要純顯示而非可以點選，就在這個option當中加入disable屬性即可
        範例:
        <option value="" disabled >請選擇人名</option>
        //value空值即可


    7.select多選
        select多選其實跟checkbox很像，基本上差別不大，只是顯示的方式不同而已。
        以下是用範例進行解說

        data(){
                return{
                    chose_ary:[],//為陣列形式
                }
        }


        <select v-model="chose_ary" multiple>//只需要加上multiple即可
            <option value="三民區">三民區</option>
            <option value="小港區">小港區</option>
            <option value="琴雅區">琴雅區</option>
        </select>


        {{ chose_ary }}
        //顯示為一個[]，當選擇三民區 會呈現["三民區"]。
        //再點選小港區 顯示["三民區","小港區"]。依此類推



ol.v-on
    v-on雖然可以觸發資料更動，但大部分比較少會使用到。多數情況都是與methos做綁定，透過methos再來更動data。
    v-on跟v-bind一樣都有縮寫形式，但兩者的縮寫形式是不同的
    v-on的縮寫形式是"@"
    範例:
    <button type="button" v-on:click="function"><button> 原先
    <button type="button" @click="function"><button> 縮寫


    1.使用代入參數的方法決定哪個布林值要轉換:
        在還未學習到這個方式前，我個人轉換的方式如下:
            change(){
                this.isShow = false
            }
            or
            change(){
                this.data.box = this.data.box ? false : true;
            }
        但其實可以使用代入參數的方法就不需要建立如此多的methods了
        範例:
            change(key){
                this[key] = !this[key];
                //邏輯就是讓代入資料路徑代入key，所以就是變成 this.[資料路徑]
                //而這個this[資料路徑]等同於this.資料路徑 也是其中一種物件屬性的指定方法
                //也就是說假設上面的key的值若原本是false，那就改為相反的。false的相反就是true。反之，true的相反是false。 
            }

    2.v-on綁定原生DOM事件:
        其實v-on:click就是綁定原生的事件。
        click本身就是原生的事件
        addEventListener('click',function,同步與否)
        下面會介紹搭配vue使用的事件用法

        submit事件
        submit事件是當form表單符合的條件後就會觸發
        範例:

        <form v-on:submit.prevent="function">//這邊使用了.prevent的修飾符，這個修飾符的作用是取消本身預設的作用 form本身預設的作用就是submit

            <input type="text" v-model="name">//因為裡面只有一個input 若這一個input被寫入內容並離開焦點時 就等於符合了條件
            <button>送出</button>//button若是不加上type原先就有submit的功效。然後因為是在form內，所以當form綁定了function，裡面的button也會綁定

        </form> 

        動態事件:
        v-on可使用動態綁定。何謂動態綁定?你可以依照資料庫的資料決定你的標籤要綁定哪一種事件
        範例:

        data(){
            event:'click'
        }
        method:{
            sayhi(){
                console.log('哈囉')
            }
        }

        <button type="button" @[event]="sayhi">送出</button>
        //通過修改event的資料，可以改變觸發的事件
        //不過在實戰中比較少用到這個動態事件


        動態物件的方法:
        除了多個 v-on外
        還可以使用動態物件的方法在同一個標籤綁定多個事件
        範例:
        <button type="button" @="{

            mousedown:function, //mousedown 為按下觸發事件
            mouseup: change,  //mouseup 為放開觸發事件
            事件:function,

        }">送出</button>
        //使用這個方法要注意，這個方法沒有辦法代入參數


    v-on DOM事件處理技巧:
        在原生JS內，只要觸發事件，事件都會回傳資料
            function(e){
                console.log(e);//回傳的資料
            }
        //在這裡面有包含你點擊的座標等等資料
        vue很多事件若在原生JS實現的話，內都要運用這些資料才能處理。
        而今天這邊要介紹如何使用這些資料

        若function有參數
        倘若我們function有參數，但又需要接收回傳的資料時該怎麼做?
        範例:
            function click(iteam,e){
                console.log(iteam,e);
            }

        <button type="button" v-on:click="click('代入的參數',$event)">按下</button>//只要在參數後加上$event 那這個就會是e的參數

        取得原生input的內容:

            function get(e){
                let value = e.target.value;//原生的取得value的寫法
            }
            <input type="text" @change="get">//注意，這邊是沒有綁定v-model的。如此當失去焦點後，get這個function就可以取到input內使用者輸入的資料

        監聽案件事件:

        function up(e){
            let code = e.keyCode;//keyCode是使用者按下的數字對應號碼
        }


        <input type="text" @keyup="up">//因為使用keyup，所以在每一次使用者按下按鍵時我們都能取得使用者按下的按鍵對應的號碼



ol.修飾符(modifiers)
    修飾符基本上來說就是扶助指令運作，用於v-model or v-on上
    那修飾符的位置都是在指令的後方
    範例:v-model.xxx="" //xxx為修飾符放置位置

    1.v-model修飾符
        首先我們先介紹v-model
        v-model修飾符有三個 lazy(延遲),number(純數值),trim(修剪)
        備註:這邊在使用修飾符之前記得要開啟vetools

        1.lazy 延遲:
            綁定lazy的用處是不會馬上綁定，當失去焦點時才會綁定。就有些類似原生的input、與change的差別
            也就是說當加入了lazy，input的值在修改時並不會馬上更動資料庫的資料，而是等到失去焦點時才會套用到資料庫的資料當中
            //失去焦點的意思是指當你點到非這個input時，那就是失去焦點。點到input的時就是在焦點內。
            範例:
                <input type="text" v-model.lazy="data">

        2.number 數值
            這個修飾符的功用是讓輸入框輸入的資料轉為數字而非是字串，常用於取得計算資料中
            //注意:使用這個功能並非就是強制使用者只能輸入數字，使用者輸入字串依然可以輸入。所以可以搭配input type的number使用
            範例:
                <input type="number" v-model.number="data">
        
        3.trim
            有時候當我們需要取得值不能有空白時，那就可以使用trim。trim可以將兩側的所有空白值都消除後才將資料傳送至資料庫。
            //注意 只有兩邊的空白消除，若字串中間有空白還是會有空白內容
            //原生strings.trim()的效果

    2.v-on修飾符

        按鍵修飾符:

            別名修飾:
            所謂別名修飾就是當按下特定的按鍵時才會觸發
            常用的共有這幾個種類:
            .enter, .tab, .delete, .esc, .space, .up, .down,
            範例:
            <input type="text" @keyup.enter="function">


            組合觸發:
            當我們需要有多個按鍵組合起來才能觸發時，就在多加一個修飾符
            <input type="text" @keyup.shift.enter="function">
            
            特定案件:
            其實與別名差不多，別名是常見的按鍵，那特定就是指定的鍵盤按鍵
            <input type="text" @keyup.h="function">//按下鍵盤上的h才會觸發


        滑鼠修飾符:
            當我們使用click事件按下滑鼠時，都會觸發click事件，但若是只要特定鍵，如右鍵有反應，那就需要搭配相關修飾符
            //這就類似原生contextmenu事件


            .left//左鍵觸發
            .right//右鍵觸發
            .middle//中鍵觸發

            範例:
                <div @click.right="function"><div>

        事件修飾符:
            事件修飾符最常出現的就是.prevent 這個就是原生function內的e.defaultPrevent() 取消預設事件
            很多事件都有屬於它原本的預設事件，e.defaultPrevent()就是阻止預設事件觸發的代碼
            從這方面我們就可以知道事件修飾符的功用了，以下開始介紹:

            .stop 調用e.stopPropagation 這個是阻止冒泡(防止向外尋找)
            //這個也就是說當不會觸發點選的區塊父層的事件

            .capture 事件由外而內查找 稱捕獲/捕捉

            .self 只會觸發自己的事件 也就是不會向內也不會向外觸發子父層的事件
            //使用這個的話需子父層都套上，才不會點擊到子層，父層又觸發一次。

            .once 只觸發一次回調 白話說就是只會觸發一次
            //原生的 function once(){}
            //buttonEl.addEventListener('click', function (e) {
                console.log('綁定一次');
            },{once: true});


ol.option_API

    目前我們學習的Vue撰寫方法就是optionAPI，但其實vue還有一種寫法名為compostionAPI。
    兩者寫法差別極大，但效果可以是一樣的。因為compostionAPI難度較大，所以新手入門接觸都會推薦學習optionAPI
    目前這章不會介紹到compostionAPI，都會著重於optionAPI的教學
    ex.注意!使用option API不要使用箭頭函式。除非你已經在methods內以傳統函式建立。在傳統函式內使用箭頭函式才不會產生問題。

        methods:
            methods本身是一個物件
            methods可以使用指令來觸發。也就是v-on:click以外呢，其他的options API都可以來觸發methods。
            如生命週期、另外一個函式等
            範例:
                Vue.createApp({
                    data(){
                        return{

                        };
                    },
                    created(){
                        this.fn1();//可在生命週期觸發
                    },
                    methods:{
                        fn1(){
                            console.log('安安')
                        },
                        fn2(){
                            fn1()//亦可以透過其他函式觸發
                        },
                    },

                }).mount('#app');


            參數帶入:
                在原生的JS中，若我們建立一個參數，但使用時沒有帶參數進去，這時參數會是undefined
                範例:
                    function(a,b,c){
                        console.log(a,b,c)//顯示undefined
                    }

                那當我們想要獲取事件回傳的資訊，也就是原生e.target等地資訊時，我們可以這麼做。
                    範例:
                        methods:{
                            fn(a){//參數為自訂義。
                                console.log(a)
                            }
                        }

                    <buttom v-on:click="fn($event)"></buttom>//如此就可以取得你點擊後回傳的資訊

                    若是原生JS則是要用addevent or on事件才會捕捉到事件回傳。
                    若不使用$event的話，在v-on使用e.target是沒有用處的喔。
                    補充:若有多個參數，則依據你在第幾個參數放上$event來決定參數代入的順序。


            使用methods處理複雜資料:
                vue常常用來開發電商網站，而電商網站最常用上的就是購物車
                以下將會示範將商品加入購物車的基本操作。
                範例:

                    HTML:
                        <div class="wrap">
                            <ul>
                                <li v-for="iteam in products" :key="iteam.name">
                                    商品:{{iteam.name}}
                                    <button type="button" v-on:click="toCar(iteam)">加入購物車</button>
                                </li>
                            </ul>
                            <h3>購物車</h3>
                            <ul>
                                <li v-for="iteam in buy_car" :key="iteam.name">
                                    {{iteam.name}}/{{iteam.price}}
                                </li>
                            </ul>
                            {{filter(total_money)}}//這邊會呈現NT$ (計算後金額)
                        </div>

                    JS:
                        
                        Vue.createApp({
                            data(){
                                return{
                                    products:[],//商品陳列
                                    buy_car:[],//購物車 商品儲放處
                                    total_money:'',//購物車內商品總金額
                                };

                            },
                            created(){
                                this.products = products_data;//取得商品資訊
                            },
                            methods:{
                               toCar(iteam){//將取得的資訊代入
                                    console.log(iteam);
                                    //這邊取得的會是products物件抓出來的內容，但本身並不是products裡面的資訊。
                                    //拿變數來說
                                        let a = 1;
                                        let b = a;
                                        b = 2;
                                        console.log(a);// 1
                                        今天只是將a的資訊賦予給b
                                        而非直接代入a變數的路徑。

                                    this.buy_car.push(iteam);//將取得的資訊加入購物車陣列
                                    this.total();
                                    //因為總金額是看商品金額在更動。所以當商品更動時就重新計算一次。
                                    //主要是雖然有function但沒有觸發funtciton就不會執行。所以這邊就是觸發執行

                               },
                               total(){
                                    let total = 0;//建立一個數字當作載體
                                    this.buy_car.forEach(data => {
                                        total += data.price;//執行for將目前購物車的所有價格相加
                                    });
                                    this.car_total = total;//將相加後的金額加入資料中
                               }
                            },
                            filter(price){
                                return `NT$ ${price}`//這邊會回傳代入字串，可以置放於{{}}中顯示。就不需要在HTML撰寫字串
                            }
                        }).mount('.wrap')

ol.computed
    computed是當資料更動時，用來渲染網頁的功能。
    以下將會介紹computed的運作。
    使用computed可以跳過資料的部分直接渲染網頁。
    也就是說他會取出資料進行處理並渲染。而非傳統的使用資料渲染後再由computed操作。
    範例:

          Vue.createApp({
                    data(){
                        return{
                            data:100,
                            text:'測試文字',
                        };
                    },
                    computed:{//首先先在vue元件內新增一個computed物件

                        total(){//緊接著新增一個function。這個function的結果會直接渲染網頁

                            let total = 2
                            this.data + total;

                            return this.data;
                        }

                    }
                    created(){
                        this.fn1();//可在生命週期觸發
                    },
                    methods:{
                        change(){
                            data = 101;
                        }
                    },

                }).mount('#app');


            HTML:
            {{ total }}//如此這邊就會顯示102

        備註:
        看似跟methods內的function很像，但其實是有差別的。
        computed的total並沒有在任何一個methods的function內及指令來觸發。
        computed是當指定資料更動以後並且物件內的fuction有出現HTML內(不管是作為參數或是文字顯示)，就會進行觸發。
        那何謂指定資料呢?以上面的範例來說就是在computed內的total()中
        我們有使用到this.data。這就是所謂的指定資料。當這個this.data的值有更動時，total就會執行。
        若this.data沒有變動只更動this.text，那麼total就不會執行。而是會保持讓上一個執行的結果，也稱為暫存結果。
        暫存結果補充:所謂暫存結果就是執行後的結果，會占存在瀏覽器中。

    ol.手法:
        在computed中總共有兩種手法(用法)，為getter, setter。

        一.getter
        getter也就是上面所以使用的手法。將資料給取出做處理後渲染畫面。


        二.setter
        setter與getter相反。setter會將資料處理後再返回至資料庫中。
        那麼setter該如何使用呢?
        以下使用code範例進行解說:

            <input type="number" v-model.number="num"> //這邊對應的是資料庫中的num
            <button type="button" @click="total = num">更新</button>
            //這邊@click = "total = num"的意思是 將 num 賦予到computed內的total的值。
            //而total的值是set(val)中的val

            total 的值：{{ total }}<br>//這邊total則是使用get return的值
            sum 的值：{{ sum }}//sum則是資料庫中的值



            const App = {
              data() {
                return {
                  num: 10,
                  search: '',
                  products: [
                    {
                      name: '蛋餅',
                      price: 30,
                      vegan: false
                    },
                    {
                      name: '飯糰',
                      price: 35,
                      vegan: false
                    },
                    {
                      name: '小籠包',
                      price: 60,
                      vegan: false
                    },
                    {
                      name: '蘿蔔糕',
                      price: 30,
                      vegan: true
                    },
                  ],
                  carts: [],
                  sum: 0,
                }
              },
              computed: {
                total: {//這時的total是個物件
                  get(el) { // computed get 會把 data 裡面的資料取出
                    console.log('get', el); //這邊el的參數是vue的相關資料
                    let total2 = 0;
                    this.carts.forEach(item => {
                      total2 += item.price;
                    });
                    return this.sum || total2;
                  },
                  //前面提過當指定的資料更動時會觸發get

                  set(val) {
                    console.log('set', val); 
                    this.sum = val;
                  }
                   //set 是把資料重新調整好後，寫入到資料及裡面
                   //而當computed要被設值時，set就會觸發
                   //@click="total = num" 就是在設total的值
                   //這邊total是對應total()這個物件
                }
              },
              methods: {
                addToCart(product) {
                  this.carts.push(product)
                },
              },
              created() {
                console.log(this);
              }
            };
            Vue.createApp(App).mount('#app');

        
ol.watch 監聽單一的資料
    watch與computed有些類似，當監聽(指定)的值有更動的時候就會進行觸發。
    watch的差別是:
        1.總共有兩個參數 分別為此次帶入的值及上一次帶入的值
        範例:
            watch:{//一樣使用物件形式

                template(n,o){// 這邊的template則是(指定)監聽的資料
                    console.log(n,o)
                    //這邊的n就是帶入此次的值，o則是上一次的值
                }

            }

        2.一次僅能監聽一個資料 但可更改N個變數(這邊N個就是指無限多)
        補充:而computed則是可以一次監聽多個事件，並且會產生一個值，也就是return的值。可以用來呈現於畫面上。
        甚麼意思呢?也就是我可以直接將computed中的function套入{{}}中讓{{}}呈現return的值
        假設return的值是10這個數字，那我在填寫{{function名稱}}會回傳的則是return的值
        
        3.載入時不會觸發而會等到更動時。
            若使用computed當載入時就會進行一次資料的更動。而watch則是載入不會更動，等到使用者處理的時候才進行更動。


    watch監聽多個資料(深層監聽):
        其實watch亦可以進行多個資料監聽，但較為複雜。
        首先監聽的資料要是同一個物件內的值。
        其次watch的監聽方式也要改變。
        範例:
            watch:{
                obj:{//這邊是物件名稱
                    headler(n,o){//這是監聽的控制器 一樣會產生新值與舊值
                        console.log(n,o)//此時的值是回傳一整個物件，而非單一值 
                    },
                    deep:true;//這個deep則是當有使用到深層監聽時才會使用到的變數。預設都是false。當使用深層監聽時要將其開為true

                }
            }

ol.Vue元件生命週期
    雖然這邊講解到元件，但其實Vue本身就是一堆元件所組成的概念。
    下一章將會理解到元件，所以先理解生命週期會更好的學習元件這個部分。

    Vue.createApp本身就是一個元件，而此元件底下也有大大小小的元件。如methods等。
    而為甚麼會被稱為是生命週期呢?
    因為Vue在載入不同的資料時，元件其實都是在卸載及加載，每一個卸載及加載被稱為一個週期，而這正是一個循環的週期，也被稱為生命周期。
    而各個周期也可以在元件中監聽:
    例如:
    Vue.createApp({
        data(){
            return{
                text:'測試文字'
            }
        },
        beforeCreate(){//只要在元件中加上生命週期的名稱即可監聽。當觸發到這個生命週期時，這個function就會啟動。
            console.log(this.text)
        },
    })

    生命週期順序為:

    一.beforeCreate 先準備資料
        這時資料還在準備中，所以是無法取得資料狀態的，若強行取得只會顯示undefined

    二.create 資料準備完成
        這時就可以取得資料資料

    三.beforeMount 已經先準備好HTML的結構 但還未渲染

    四.mounted HTML已經渲染 但還不能操縱JS元素。
        雖然HTML已經渲染，但在mounted這個狀態時其實是暫停的狀態，也就是在進行渲染但未完成，所以若是要用JS操作元素的話，一定要在mounted之後。
        而當過了mounted以後，基本上Vue基本的元件已經加載完成，剩下的則是資料的更動及離開前的銷毀。
    
    五.beforeUpdate 資料更動前
        當資料更動時畫面自然就要重新渲染。beforeUpdate及updated就是渲染前與後。

    六.updated 當資料更動後

    七.activated 占存資料啟用
        當講解到這兩個狀態時就不得不提到v-if與v-show差別。

        v-if是會將資料卸載並重新加載的
        而若是不想要讓資料重新加載但又想要使用v-if的使用功能時，就需要用到keep-alive這個標籤
        而當使用keep-alive這個標籤時就會觸發activated及deactivated這個生命週期。

        使用方法為:
        <keep-alive>//只需要將不想重新加載資料的v-if元素放在keep-alive內即可。
            <p v-if="isShow"></p>
        </keep-alive>


        v-show則純粹只會讓元素跟資料display:none or 顯示

    八.deactivated 占存資料不啟用。

    九.beforeUnmount 卸載過程 尚可抓到資料

    十.Unmounted 卸載完成 尚可抓到資料


ol.元件:

    看到這裡大概都知道元件實際上是甚麼東西了。那為甚麼會需要使用到元件呢?
    因為使用元件有幾樣特色:

    一.增加程式碼的使用性
        何謂增加使用程式碼的使用性呢?好比說今天你有兩個地方需要用到相同的function。
        那妳可以使用元件的function。那麼就只需要撰寫一個function即可。
        若有需要修改也不需要兩個地方的function都修改，只要修改元件的funcion，那兩個地方都會同步的更新。

    二.避免單一檔案過大及方便管理
        當你在撰寫專案時，程式碼會有幾百行是常見的事情，所以你可以使用元件，讓要使用的區塊加上要使用的功能元件即可。
        一來避免檔案過大，二來修改的時候方便管理及更新。

    三.元件功能獨立
        假設今天你有多個區塊，例如head、main等。而你只要在main的區塊導入外部資料使用AJAX。那你只要在main這個元件中使用即可。
        head的功能不會因此而受到影響。

    
    註冊元件的手法:

        註冊元件須知:
        1.需再createApp後，mount前進行定義。

        2.元件需指定一個名稱，所以需要將Vue主元件(createApp)賦予變數。
        範例:
            app = Vue.createApp({//這也被稱為根元件
                data(){
                    return{
                        text:'外部元件文字'
                    };
                },
            });


            app.mount('#app');//這正是mount，所以定義元件需要在這之前。
            這邊定義的Vue寫法與一直以來不同，但其實原理是一樣的，只是因為需要註冊子元件，
            所以與原先的寫法才會有差別。
    
        3.元件結構與最外層的根源建結構無異。(除了增加template的片段)
            直接看範例解說:
            app = Vue.createApp({//這也被稱為根元件
                data(){
                    return{
                        text:'子元件文字'
                    };
                },
            });
                .component('自訂義名稱',{
                    data(){
                        return{

                        }
                    },
                    template:`<div>{{text}}</div>`//被稱為元件的樣板
                });


            app.mount('#app');


            <自定義名稱></自定義名稱>//template的用途就是渲染畫面

            //如同上面所敘述。增加子元件需要再createApp之後及mount之前。
            //而子元件的註冊(增加)只需要在createApp後使用類似Axios的.then的方式即可註冊。
            //並且註冊的元件除了增加template外，其他的都與根元件(createApp)無差別。
            //而template的作用是將資料及標籤渲染到網頁上
            //template的使用方式有些不同。首先我們需要在template建立好預設的標籤及要帶入的資料。
            //其次我們要以子元件的名稱定義一個標籤。如此標籤就會帶入我們預先建立好的tempalte資料與標籤。
            //記住，每個元件名稱都為獨立，不可使用相同名稱。
            補充:
                除了用以上形式來掛載子元件外，還可以使用以下方式來掛載。方式與規則都一樣，都需要再createApp後mount前:
                app.component('name',{
                    data(){
                        return{

                        };
                    },
                    template:`<div>{{text}}</div>`
                })

                app.mount(#app) 




        4.另有prop,emits等資料傳遞及事件傳遞
            每個元件的資料、事件都是獨立的，若有需要引用到外部or內部元件就需要使用prop、emits的功能。

    全預註冊與區域註冊:

        全域註冊
            就是直接將子元件給掛載到跟createApp同層。就如同剛才的範例。
            全域註冊常用於中小型專案、一般頁面開發。


        區域註冊
            區域註冊則以範例進行說明:

            app2 = {//首先會先在VueCreateApp外建立一個物件

                data(){
                    return{
                        text:'區域註冊'
                    }
                },
                template:<div>{{text}}</div>
            }
            //物件內的內容就是建立子元件的樣板


            接著選定要掛載的元件，並加上components:{}的物件並加入上方所建立的子元件樣板。

            app = Vue.createApp({
                data(){
                    return{
                        text:'子元件文字'
                    };
                },
                components:{
                    app2,
                }
            });
              
            app.mount('#app');
            //如此這樣就算註冊完成。

            而區域註冊會用在甚麼時候呢?與全域註冊又有甚麼差別?
            區域註冊是會限定在特定元件下才能使用。限定使用可以理解，但要怎麼在特定元件下呢?
            其實也就是將區域註冊的標籤加入到掛載的template中
            讓我們看看範例:
                 app.component('name',{
                    data(){
                        return{
                            text:''
                        };
                    },
                    components:{
                        app2,
                    },
                    template:`<div>
                        {{text}}
                        <app2></app2>
                    </div>`
                })

            而區域註冊常用於Vue cli。原因是便於管理。


    模組化:
        其實模組化並不難理解。其實只是將元件獨立為一個檔案，並透過ESModule導入而已。
        直接上範例:
        
        外部JS檔:
        export default{//此為物件
            data(){
                return{
                    text:''
                };
            },
            template:`<div>{{text}}</div>`
        }

        導入:

        import name4 from '路徑'//這個name4就是導入的檔案在全域下的變數名稱

         app.component('name',{
            data(){
                return{
                    text:''
                };
            },
            components:{
                name4,
            },
            template:`<div>
                {{text}}
                <name4></name4>
            </div>`
        })
        補充:
        若是要掛載到根元件底下，那就直接使用components:{}後直接加到HTML的標籤即可。

    
    元件樣板製作及綁定方式:
        所謂樣板就是HTML。本章介紹的就是樣板有哪幾種建構方式及如何使用綁定並運用到畫面上。

        樣板的建立方式:

            template:
                在前面的範例都有提到，簡單的來說在建立元件時裡面都有一個template屬性
                而template的使用方式就是使用反引號 ` 並在內使用HTML的標籤
                若要運用template的話，就使用元件的名稱建立標籤並加入到HTML的body內即可。

            x-template:
                x-template與template的運用有些差異。
                元件建立方式一樣，只不過元件的template則是使用單引號
                範例如下:
                
                首先先建立一個元件並掛載。
                app.component('alert',{
                    data(){
                        return{

                        };
                    },
                    template:'#alert_template',//這邊帶入的會是一個名稱。對應script的id。這邊須注意''內是使用DOM的方式指定
                })

                其次到HTML標籤新增一個script

                <script type="text/x-template" id="alert_template"></script>
                //這個script需要給予一個type="text/x-template"及id。這個id將會對應到我們template的名稱。

                而script內就是放置template的標籤

                <script type="text/x-template" id="alert_template">
                
                    <div>
                    {{text}}
                    </div>

                </script>

                最後直接將元件名稱以標籤的形式置放在HTML即可。
                <alert></alert>

            單文件元件:
                這其中就包含了JS、HTML、CSS
                這個章節並不會介紹。在cil課程將會教學。使用上與x-template較為接近。

    props 向內層元件傳遞資料

        靜態傳遞 由外部傳入內部:
        使用範例來解說:

        Vue.createApp({
            data(){
                return{
                    imgUrl:'https://chiyum.github.io/holdkibor/img/logo.png'
                }
            },
        })
            .component('photo',{
                props:['url']//導入外部資料用。可以是陣列也可以是其他形式
                template:`<img :src="url">`//這邊注意src是用v-bind 抓的是上方的url
            })

        <photo url="https://chiyum.github.io/holdkibor/img/logo.png"><photo>//由標籤靜態傳遞資料 將網址傳給props

        總結:資料導入流程是這樣的 由標籤導入網址賦予給props的url > 接下來template內的src再去抓取prors的url資料。


        動態傳遞:由外元件導入:

        一樣使用上方的範例:

            <photo v-bind:url="imgUrl"><photo>//這邊的話使用v-bind的方式將外部資料給導入到photo的v-bind:url的屬性中，再由url套入到props
            與靜態同樣都是從標籤導入資料，而兩者差別在於，靜態的是你需要操控DOM或者親手改變url的值。動態是透過v-bind，那你只需要更改Vue資料庫的資料就可以做更換。

            口訣:看到這邊可能還不太明白或是在開發時容易搞混props的傳遞方法，所以可以計下這個口訣"前內、後外"
            所謂前內就是掛載的子元件，因為在內部所以稱為內。
            而後外就是外部所導入的資料。


        單向數據流:
            看到這邊都理解如何由外部導入資料給予內部，但還有一點需要注意，那就是資料的導入是單向性的，所以你怎麼從內部更改，外部的資料也不會改變。
            範例:


            .component('photo',{
                props:['url']
                template:`<img :src="url">
                          <input v-model="url">//不管在這個url如何更改，資料都是不會修改的。
                `
            })

        命名限制:
            所謂命名限制就是HTML的屬性都會是以小寫的方式進行命名，所以當你使用大寫命名時並自動幫你轉小寫，那麼就對不上你在元件中的變數。
            那若要解決怎麼做?

            範例如下:

            <photo v-bind:test-url="imgUrl"><photo>//屬性這邊改為-

            .component('photo',{
                props:['testUrl'],//props這邊以小駝峰呈現
                template:`<img :src="url">
                          <input v-model="url">//不管在這個url如何更改，資料都是不會修改的。
                `
            })

            總結:若資料想使用小駝峰形式，那屬性的部分就只需要將要轉變為大寫前的文字前加個-並都改為小寫即可。


    元件型別與驗證:

        props型別技巧:
            當我們在使用prors傳入資料時，若使用v-bind及HTML原本的屬性所導入的type其實是不一樣的。
            原本屬性再帶入值時，這個值一率都會是字串。
            而若使用v-bind的話，資料本身是甚麼形式就會帶入甚麼樣的形式。
            範例:

                Vue.createApp({
                    data(){
                        return{
                            outsideMoney:300,
                        }
                    },
                })
                .component('data',{
                    props:['money']//導入外部資料用。可以是陣列也可以是其他形式
                    template:`<div> value:{{money}} typeof:{{typeof(money)}} </div>`
                })


            <data money="300"></data>//顯示為字串形式
            <data :money="outsideMoney"></data>//顯示為數字形式
            補充:v-bind是可以使用表達式。

        定義及型別驗證:
            在實戰中不太會用到全部所學的技巧，但常用的有:

            一.型別驗證
                若需要使用型別驗證的話，prors的值就需要改成物件。
                範例:

                Vue.createApp({
                    data(){
                        return{
                            dataA:fn()=>{return 'a'}
                            dataB:300,
                           
                        }
                    },
                })

                .component('data',{
                    props:{
                        propA:Function,//值寫的是指定型別，若非指定型別就會跳錯但不會影響運作
                        propB:[String,Number],//若有多個型別檢查，可以使用陣列

                    },
                    template:`<div>A:{{propA}} B:{{propB}}</div>`
                })

                <data :prop-a="dataA" :prop-b="dataB"></data>
                補充:null,undefined會直接通過

            二.預設值、是否必填

                是否必填,必要值:
                呈上範例:
                若有需要必要值及同時型別判斷可以這樣使用。
                
                 .component('data',{
                    props:{
                        propA:{//這邊轉為物件
                            type:Number,//type為型別判斷
                            required:true,//是否存在這個值
                        },
                        propA:{
                            type:Number,
                            default:300,//預設值。當外不沒有值，就使用預設值。
                        },
                    },
                    template:`<div>A:{{propA}} B:{{propB}}</div>`
                })

                <data :prop-a="dataA" :prop-b="dataB"></data>
        

    emits 向外傳遞事件:
        上一章已經解說完外部導入內部資料的props
        這章開始介紹emits將內部資料給外層接收。但這章會比props來得更複雜一些。
        emits在傳遞時，它其實是一個事件。所以不一定要傳遞資料，它也可以傳遞事件來觸發外層事件。
        範例:

            子層端:

              .component('data',{
                    template:`<div @click="active"></div>`,//這邊一樣是v-on的觸發方式
                    data(){
                        return{
                            text:'內部文字',
                        }
                    },
                    methods:{
                        active(){
                            
                            this.$emit('test',this.text);//('')為自定義名稱，這邊以test作為範例。而this.text則是此元件的資料，我們要將其傳遞到外元件
                            console.log('內層觸發');//這邊可以使用console.log來讓自己知道是否有觸發子層事件
                        }
                    }
                })



            外層端:

                <data v-on:test="active"></data>
                //當內層建構完成後，接著在外層的元件標籤上操作
                //一樣記住口訣。"前內、後外"
                //前面test是我們$emit所定義的名稱
                //後面的active則是外層元件methods的事件


                methods:{//這邊的methods是外層的

                    active(text){//外層設置參數，這個參數會是子層$emit所傳回來的資訊
                        console.log('觸發外層');
                        this.text = text;//將子層回傳的資訊套入父層的元件中
                        console.log(this.text);
                    }

                }

                如此便完成了傳遞。若是不需要傳遞資訊則省略$emit後面的元件資料即可


slot 差巢:
    slot差巢的用意是在根元件內插入一項可以由根元件控制的區塊，好處是此區塊是屬於根元件，不需要透過props或是emit即可操作。
    那如何操作呢?

    js部分:

    app.component('test',{
        template:`
        <div>
            <slot></slot>//js部分只需要在子元件內插入一個slot標籤即可
        </div>
        `
    })

    html:

    <test>
        <p>外部區塊控制文字</p>
        //在html的部分就可以直接插入我們想要的標籤及內容
        //外部的p標籤插入的位置就會是子元件中slot插入的位置
    </test>

    預設值:
    有時候使用slot時，外層並不會有資料的話，那就可以使用預設值。當外層沒有插入內容，就會使用slot的預設值。
    而預設值設定也很簡單，只需要在slot標籤中加入想要的標籤即可。
    <slot>
        <p>預設值文字</p>
    </slot>


    多個差巢(slot):
    如果說想要一次在元件內插入多個slot也沒有問題，但如果有多個slot就需要有名稱來讓系統判別哪個slot要插在哪個部分。
    js部分:

    app.component('test',{
        template:`
        <div>
            <slot name="head"></slot>//在slot的標籤使用name屬性給予系統判斷的標準
            <slot ></slot>//若沒有填寫則為預設 對應外部的defualt名稱
            <slot name="footer"></slot>
        </div>
        `
    })

    html:

    <test>
        <div v-slot:head><div>//標籤部分使用v-slot來給予對應名稱
        <div v-slot:default><div>//若沒有填寫的slot對應此標籤
        <div #footer><div>//v-slot的縮寫
    </test>


    slot的props:
    slot也可以使用props來獲取包裹著slot子元件的資料，原理與普通的props一樣，只是用法些許不同。
    ps.在實戰中較少使用。

    js:
    app.component('test',{
        data(){
            return{
                text:'子元件文字'
            },
        }
        template:`
        <div>
            <slot :test="text"></slot>
            //一樣是前內後外 這邊的前代表slot 後則是表子元件的資料
        </div>
        `
    })

    html:

    <div v-lost="default="test_text">//因為只有一個所以是預設值default 而test_text則是自定義名稱 不需要去對應js中":test"的名稱還是能將"子元件文字"給帶出來
    {{test_text}}//呈現"子元件文字"
    </div>

    預設值:
    slot props也可以使用預設值 當偵測不到值就會使用預設內容
    <div slot:default="test_text = '預設值文字'">
        {{ test_text }}//若子元件的slot標籤移除 :test="text" 的話 那test_text就會顯示"預設值文字"
    </div>
    

    mitt插件 跨元件傳遞資料:
    在原生vue中只能使用props及emit傳遞資料，但這限於子父層的關係，沒有辦法讓兩個元件互相傳遞。
    而若是要使用跨元件傳遞資料就必須透過mitt這個插件。ps.mitt插件不限於vue 
    https://github.com/developit/mitt <<插件網址

    用法如下:
    
    目標是將test1元件的文字傳送到test2元件中


    <script>

        import '插件網址';//引入mitt插件

        const mitter = mitt();//自定義變數名稱開啟插件

        const app = Vue.createApp({//建立根元件

        })

        app.component('test1',{
            data(){
                return{
                    text:'test1文字'
                }
            },
            methods:{
                add_text(){//當觸發此事件時傳遞資料
                    mitter.emit('add',this.text);//與vue的emit方式很像 add是自定義名稱 this.text是要傳送的資料 如此便完成發送的動作
                },
            }
        })

        app.component('test2',{
            data(){
                return{
                    text:''
                }
            },
            created(){//建議將接收的動作放在create 當我們建立這個元件時就馬上啟用
                mitter.on('add',(data=>{//此add名稱是發送動作所定義的名稱 可以理解為出發地跟目的地的概念。接著後面接一個事件，類似axios的then 參數就是emit發送過來的資料
                    console.log(data);//呈現傳送過來的資料
                    this.text = data;//將船送過來的資料賦予到此元件的text變數中
                }))
            }

        })

        app.mount('#id')






    </script>


    vue進階api

        refs:在以往使用原生或是jq開發的時候，我們取得調動元素(DOM)的頻率可以說是非常頻繁，而且基本上是必須的。
        但使用了Vue以後，我們很少會需要再使用到DOM的部分，不過偶爾還是會有所需求。
        當這個時候我們並不用去使用JQ或是原生JS，Vue就有提供快速取得DOM的方法"ref"
        步驟:
            首先我們需要在要取得的DOM上給予 ref的屬性並自訂義屬性的值。
        
            <input ref="someword">
            //這邊注意並不需要使用v-bind

            其次若我們需要在DOM剛載入時就取得的話，需要放在生命週期mounted內，若放在create的話有可能會找不到。
            mounted(){
                console.log(this.$refs);//如此便會取得所有的DOM
                console.log(this.$refs.someword);//若要取得指定DOM只需要在refs後方加入ref的自訂義值即可。
                this.$refs.someword.focus();//若有操作的需求就跟使用JS或JQ一樣即可。
            }

        telport:telport的用途是元件跨區塊。也就是說兩個不同的區塊但卻是共用同一組元件。
        結構: <telport to="{ DOM名稱 }">

        用法:
            先在使用元件的template內建立telport

                app.component('unit',{
                    template:`
                    <buttom type="buttom">點擊顯示<buttom>
                    <telport to="{#someDom}">
                        <p v-if="isShow">顯示的文字</p>
                    </telport>
                    `,
                    data(){
                        return{
                            isShow:false,//利用此變數來決定顯示與否
                        }
                    }
                });

            DOM:
                <div id="someDom"></div>
                //這邊的用途是利用"點擊顯示"的btn來決定p標籤內的文字是否顯示
                //在telport內加入標籤及內容以後，使用to來指定要顯示的位置
                //如此telport的DOM就會顯示在someDom的元素內了

        使用限制:
            只可以在mount指定區塊內運行，超出的話Vue會跳錯誤訊息至console
        
        實用技巧:
            o.取代標題
                telport是可以取代掉head內的title的
            
            
            多個telport:
                在一個元件內可以有多個telport。


        provide:
            跨元件傳遞。這邊的跨元件傳遞資料是能夠將外層的資料傳遞到內層的資料。
            與props不同，props是一層一層的傳遞。而provide可以一次跨過中間的父層，從祖層傳遞至子層。

            用法:
                首先需要在外層的元件內加入provide的屬性。provide可以是函式也可以是一個物件，兩者有些許的差異。
                這邊先使用物件的方式做介紹
                provide:{
                    someword:{//要傳送的資料
                        text:'外部資料',
                    },
                },

                接著則是內部的元件加入inject

                inject:['someword'],//與props的用法很像，如此內部的元件就可以接收到外部的資料

                function的provide:
                在大致上了解provide的用法以後，我們來了解provide函式的用法。
                provide函式與物件的區別在於，函式可以直接取得元件內的資料。
                provide(){
                    return{
                        someword:this.someword,
                    }
                }

                
            注意事項:
                若使用provide物件的傳遞資料的話，兩者的資料是不同步的。也就是說我在內層修改了someword的text
                外部的資料並不會受到影響，一樣是顯示外部資料。
                但若是使用函式的方法的話，那麼兩者的資料就會同步，不管哪一層改變了資料，其資料都會被更動修改。
                能夠更動資料的用法被稱為"響應式"。


                

                



