
JS前置觀念

---語法糖---:
語法糖只是讓程式碼看起來更簡潔，與原先並不會有使用上的差異。
在物件使用屬性都需要加分號:
但在ES6以後
若是function則直接輸入function的呈述式即可
範例:
let d ='d'
let obj = {
    a:'a',
    fn(){
        console.log('i')
    },
    b:'b',
    d,
}

除了function外，物件也可以直接代入，那麼屬性名稱就等於變數名稱，屬性值等於變數值

陣列串接---
以往來說會是 c = a陣列.concat(b陣列)
但ES6可以使用更省事的方法

C陣列 =[...a陣列,...b陣列]//...的方法是將陣列內的物件取出並排列
若沒有使用...的話，c陣列會是包住a陣列及b陣列

同時物件也可以用此方法新增

let a = {
    a:'a',
    b:'b',
}

let c ={
    ...a
}

//類陣列轉為純陣列也可以使用相同方法


---預設值---
現在參數也可以帶入預設值，假設今天有兩個參數，但使用者只代入一個那很有可能會出現bug
let fn = (a,b)=>{
    return a + b
};

fn(1,2) //3
fn(1) //NaN

傳統的方法避免的方法是
let fn = (a,b)=>{
    if(!b){b=2}
    return a + b
};

現在只需要使用預設值就可以避免錯誤

let fn = (a,b = 2)=>{
    return a + b
};


---this指向---

simple call

範例:
var someone = '全域';
function callsomeone(){
    console.log(this.someone);
};

callsomeone();//這個就叫做simple call 當前面沒有任何物件，就叫做simple call 又稱為簡易呼叫

而this的指向跟怎麼定義它沒有關聯而是呼叫的方法。假設使用simple call 就是呼叫全域
但若是使用object.callsomeone(),那就會指向前面的object內的內容。


var obj = {
    someone:'物件',
    callsomeone //將上面宣告的函式放進來
};

obj.callsomeone()//顯示物件


物件內的物件呼叫

var obj2 = {
    someone:'物件外',
    callsomeone //將上面宣告的函式放進來
    obj = {
        someone:'物件內',
        callsomeone //將上面宣告的函式放進來
    };
};

obj2.obj.callsomeone()//顯示物件內


常見陷阱


var obj = {
    someone:'物件',
    fn(){
        callsomeone();//它其實也算simple call 但平常並不會這樣使用
        //注意這裡，callsomeone前面並沒有任何物件
    }
};

obj.fn()//顯示全域


var obj = {
    someone:'物件4',
    fn(){
        setTimeout(()=>{
            console.log(this.someone)
        });
    },
};

obj.fn()//顯示全域 原因是setTimeout是在全域下執行而非object

補充:若是在事件觸發後，this通常代表觸發的元素本身
總結:this的指向跟調用(呼叫)的方法有關



---箭頭函式---

特點:除了語法糖外，特點就是它沒有自己的this
範例:
let obj = {
    callName:function(){
        console.log(this);//顯示物件本身
        setTimeout(()=>{
            console.log(this)//在傳統函式中會指向window，但若是使用箭頭函式則會跟著父層指向相同，在這個範例中也就是指向物件。
        }),
    }
}

obj.callName();


常見陷阱
let name = 全域;
let obj = {
    name:'小明',
    callName:()=>{
        console.log(name);
    }
}

obj.callName()//顯示全域。與傳統函式不同，前面說到箭頭函式會跟著父層指向相同。但在這個範例中obj內的callname外層並沒有函式，準確地來說它的外層函式就是全域，所以這個this就指向全域。


let name = 全域;
let obj = {
    name:'小明',
    callMe(){
        let callName = ()=>{
            console.log(this.name);
        };
        callName();
    },
};

obj.callMe()//顯示小明 因為在callname外層的函式是傳統函式，也就是指向物件本身，而箭頭函式則是跟隨外層函式來定義this。理所當然地也就跟著callMe的this定義。




---元件結構(關注點分離/MVVM)---
所謂元件結構就是將一個功能所運用到的所有內容都放在一個物件中，包含函式、儲存的資料等
依所需情況調用及觸發，每一個屬性都各自獨立但卻又相關，所以稱為關注點分離。
基本的元件結構有:
1.資料
2.方法、觸發器
3.生命週期


const click ={
    data:[],
    function(){

    },//若是要渲染HTML結構，盡量在一個function內
    init(){//稱為生命週期，一開始載入後所要執行的函式
        this.function
    }
}


範例:
const click ={
    data:[],
    fn(){
        console.log('安安你好')
    },
    init(){//稱為生命週期，一開始載入後所要執行的函式，通常是開發者自訂義
        this.fn();
    },
}
click.init()


---物件、陣列、函式傳參考---

在我們創立一個物件的時候，其實並非是像純值(如字串、布林)一樣將值賦予到變數上，而是將物件的位置傳給變數。

當我們新增一個物件就相當於在網頁的儲存區建立物件。而當我們要取用物件時就會自動導向物件的路徑。
好比賦予變數物件，讓我們從以下範例解釋。

let a = {x:1};
//在這操作中瀏覽器共做了兩件事
1.在瀏覽器的儲存區中新增{x:1}的物件
2.將儲存區的物件路徑賦予到a

所以當我們使用console.log(a)時，其實是從a這個路徑瀏覽{x:1}這個物件。
由此可知，當我們同時賦予兩個變數一樣的物件時，他們的路徑都是一樣的，其中一個物件屬性及值更動，另一個也會同步。

let a= {x:1};

let b = a;

b.x = '2';

console.log(a.x)//顯示2

須知注意:
但是我們得注意，當我們又新增了一個{}時，就等同於又新增了一個路徑，就算裡面內容相同也並非是同一個路徑。
範例:

let a = {x:1};

let b = {x:1};

console.log(a===b)//回傳false


淺深層複製

當我們要複製物件內容但又不共用同一個參考路徑時該怎麼做呢?
有兩個方法，淺層及深層。

淺層:
淺層就是複製物件內的值與屬性，但屬性的值內若有物件，那這個物件還是共用同個路徑的。
let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = Object.assign({},a);//方法一
let c = {...a}//方法二

//按照上面的範例來說，a跟b還是共用同一個x物件路徑


深層:
深層拷貝就不會有共用路徑的問題，而是會創造一個新的物件
原理很簡單，就是將物件內的所有內容都轉為字串，再從字串轉為物件。


let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = JSON.parse(JSON.stringify(a));



promise

promise 嚴格來說是為了解決非同步語法難以建構以及管理的問題。
簡單來說就是在所有資料都處理好以後，再接續執行下一步。
常用於AJAX，當處理完所有傳送及取得的程序以後，再來接續進行下一步的渲染等動作。
經典使用promise的AJAX處理套件為axios

promise會先建立一個建構式

const promise_Set = (status)=>{//套入狀態
    return new Promise(resolve,reject)=>{
        setTimeout(()=>{//讓此程式碼最後執行
            if(status){//當狀態為true時
                resolve('成功')//resolve的參數代入成功
            }else{
                reject('失敗')//reject的參數代入失敗
            }
        })
    }
}

promise_Set(true);//狀態套入
    .then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
    })
    .catch((rej)=>{
        console.log(rej)//同上會是reject的('失敗')
    })


promise串接
promise_Set(true)
.then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
        return promise_Set(true)//當在此使用return時，下一個.then/.catch就會是此promise_Set(true)所回傳的結果
    })
.then((res)=>{
    console.log(res);
})

元件中使用promise

const a = {
    data:{}
    init(){//這邊若是要用this需要使用傳統函式，因為箭頭函式this是隨著父層函式的this而定義
        promise_Set(true)
        .then(res=>{
            this.data.res = res;//在data元件中新增res的屬性及值
        })
        .catch((rej)=>{
            alert('傳送失敗');
        })
    }
}

a.init();



使用axios搭配promise

axios.get('url')//url代表連接網址
    .then((res)=>{
        console.log(res)//res回傳的資料
    }) //axios內建就有promise所以可以不用建構直接使用
    .catch((rej)=>{
        console.log(rej.response)//回傳失敗的資料
        console.log('串接失敗')
    })

post方法補充: axios.post('url',{傳送的內容});



---ES模組---

ES步驟:

1.於模組化的script上加上type="module"

2.匯出匯入觀念
匯入跟匯出有很大的關連，所以我們先說明匯出。

匯出(js)//僅在js進行

匯出又分成預設跟具名匯出

預設匯出: export default
//每個檔案只能有一個


具名匯出: export const xxx = ...
//每個檔案有多個
而匯出可以同時匯出具名及預設



匯入(html,js)//在html or js進行
既然有預設匯出，自然也又預設匯入及具名匯入

預設匯入 import 自訂名稱 from 檔案

具名匯入{具名名稱} from 檔案


匯出入方法

匯出用法
1.新建個匯出JS檔案

2.填上匯出程式碼
export default {//默認
    ...程式碼
}

export const abc{//具名
    ...程式碼
}

匯入用法

1.在要匯入的檔案中導入

import fn from './...路徑'//默認

import{abc} from './all.js'


此時fn就等於你寫在匯入JS檔案內的那一個function or obj or ary or 變數

2.使用
接下來就看你是匯入甚麼，就照原先的方法使用即可。



匯入有兩種方式:
單一匯入、全部匯入

比較建議單一匯入，因為全部匯入錯誤難以發現
單一匯入就是個別匯入
全部顧名思義就是不管有多少個匯出，一次接受一次匯入


單一:

inport {a,b} from '路徑'
//匯入a及b匯出


全部:

import * as all from '路徑'
//as 是賦予到一個變數的名稱上 all就是那個物件的名稱


sideEffect.js(沒有包含匯出的檔案):
也就是沒有使用export的內容，其實也可以進行匯入

inport '路徑' //直接導入即可



實戰:

先說明每一個 type="module"的作用域是各自獨立的。
也就是說假設有兩個script都有綁type="module"並且有匯入。
但我在第一個匯入的檔案，在第二個是無法使用的


ESM
網路上找的到的CDN的網址上若有ESM字樣基本上都可以使用import的方式匯入

inport {} from 'CDN網址'

直接使用




觀念都理解了，正式進入vue的教學。

首先vue的概念就是對應元件結構
{
    data:[儲存的資料]
    render()//渲染HTML的function(事件觸發)
    init()//載入時所執行的動作(生命週期)
    //假設今天要使用這個元件結構，就從呼喊init這個function就會執行。
}

只是vue都幫你把以上的事情都做好了，基本上只需要在指定標籤加上指定屬性，vue就會幫你做渲染


vue 環境設置
於瀏覽器安裝vue開發者工具套件
網址:https://headwayapp.co/vue-js-devtools-changelog/timeline-and-api-166716
//注意一定要從這安裝beta版本，可能是設定問題正式版沒辦法使用。

在開發者工具中可以找到vue的介面
    介面左邊會有一個根元件，點選，右邊會有data的資料庫。
    後面開發的話都會以這個根元件為主，階梯式的呈現在介面上

載入vue cdn放在head內 //這邊要注意版本，目前教學為3

<script src="https://unpkg.com/vue@next"></script>



---第一課定義元件---
型態:
Vue.createApp({//定義元件 也就是vue的起手式，類似jq的$(doc).ready

  data(){
    return{
      //資料庫
    }
  }
}).mount('DOM')// 執行元件    
//這邊的mount是將這個元件給綁定到指定的DOM


範例及解說:
Vue.createApp({//使用vue時都會先使用createApp，上面有提到類似JQ的ready
  data() {//定義一個資料儲存區 需注意的點是這邊的data是一個函式，資料是用return的方式回傳。這個作法的用意是使用原生JS內件的proxy功能，讓物件內的其他函式可以使用this.屬性調用
    return {
      counter: 0,
      text: '這裡有一段文字123'
    }
  }
}).mount('#app')//到mount之前，元件及資料儲存的定義就已經完成，mount則是綁定DOM


---第二課完整vue定義及事件--- 

型態說明:

<div> {{value}} </div>//顯示123 這邊是輸入資料路徑。
簡單的說明一下資料路徑
當我們需要調用data()這個資料庫內的路徑時，data所回傳的就是一個物件，並不需要使用data.value的方式呼叫，因為當data()將{}回傳時，{}就已經是app這個物件內的值了。
總得來說就是只需要使用要調用時只需要使用return{}物件內的值就可以了。
假設你物件內的值是物件，你要取用物件內的物件，就使用原生js的物件呼叫方法即可。


<input type="buttom" v-on:click="click"> //當DOM要觸發methods裡面的方法時，於標籤內輸入v-on:觸發事件="function" ex.這邊不需要再加個中括號了()

const app = {
    data(){//資料儲存區 ex.這邊一定要是函式
        return{
            value:'123'//通過{{屬性}}，可以將值給渲染到瀏覽器上
        }
    }
    created(){生命週期 更改data內容
        this.value = '456'//這邊之所以抓地到data的值是因為使用了return，return後的內容就會被proxy攔截。簡單來說就是return後內容父層抓地到
    }
    methods:{//方法(事件觸發) ex.會是一個物件

        click(){
            console.log('安安');
        }        
    }
}

事件型態:
HTML
<div v-on:事件="function名稱">按鈕</div>
//因為已經綁定在區塊中了，所以不需要再使用物件方法呼叫
methods.click (X)
click (O)//不需要加入()

補充:v-on事件有:
click 觸發
keyup 鍵盤  keyup這邊比較特殊,因為鍵盤有多個按鍵，所以keyup的v-on型態是這樣: v-on:keyup.enter ="function"
//其中enter為按鍵的縮寫，只要是按下enter都會觸發。
//縮寫類型有 .enter, .tab, .delete(包含刪除跟退格鍵), .esc, .space, .up, .down, .left(滑鼠左鍵), .right(滑鼠右鍵)
//按鍵縮寫好像也能直接輸入key代碼(待確認) 
input 只要input的值有改變就會觸發 與原生用法差不多(change,input)


第三課 雙向綁定

v-model 綁定到資料輸入區並與其同步，只要資料輸入區改變or v-model的內容改變，兩者都會同步 (綁定一)

當定義一個元件以後，若是要將input取得的資料輸入進資料庫需要使用v-model
相當於原生.value /JQ.val()的概念。
//亦可取得select的value

型態:
HTML
<input v-model="資料庫物件名稱.屬性名稱">//已經綁定在區塊內，所以就直接使用資料路徑即可



v-bind: 綁定輸出到HTML屬性上 (綁定二)
v-bind可以資料酷的輸出到指定的HTML屬性上
型態:
HTML
<img bind:src="資料庫名稱.屬性名稱"

稱為雙向綁定的原因是兩者已經同步，當有一方改變，另一方也會同步改變。



第四課 導入外部資料進資料區

說明:

let obj = {//外部資料 不管外部資料是甚麼形式。陣列 or 物件等都一樣可以導入
    a:123,

}

const = add{
    data(){
        return{
            data:{
                
            }
        }
    },
    created(){//當我們要使用外部資料進行渲染時，就在生命週期這邊導入外部資料，這邊在一開始載入vue的時候就會執行
        this.data = obj//如此在載入vue時，外部的資料就會導入到指定的路徑
        //這邊要注意this本身就已經代表data，所以這個data是return物件內的data屬性喔
    }
    method:{

    }
}

Vue.createApp(add).mount('#id')

---第五課 將資料傳入資料庫---
因為v-model的特性是雙向綁定，所以假設我們每一次觸發事件都要新增一筆不一樣的資料要怎麼處理呢?
範例解說如下:

 <div id="app">
        帳號:
        <input type="text" v-model="temp.account">
        <!-- v-model有個特點 假設指定路徑內沒有該屬性，那會自動新增這個屬性 -->
        <br>
        密碼:
        <input type="text" v-model="temp.password">
        <br>
        <button type="button" v-on:click="add_userdata">送出</button>
        <!-- 這邊type要使用button 否則預設定義是submit -->
        導入的帳密:{{temp.account}},{{temp.password}}
        <br>
        userdata內容:{{userdata}}
    </div>
    <script>
       Vue.createApp({
            data(){
                return{
                    userdata:[],
                    temp:{}
                }
            },
            created(){
                this.userdata = JSON.parse(localStorage.getItem('user'));//從local端取得資料
            },
            methods:{
                add_userdata(){
                    this.temp.id = new Date().getTime();//此行目的產生唯一性id 從這邊也可以有v-model的特效，物件內沒該屬性會自動新增 就跟原生JS一樣
                    this.userdata.push(this.temp);//將目前temp的內容上傳至userdata這個陣列內
                    this.temp = {};//清空
                    this.update();//輸入至local端
                },
                update(){
                    // localStorage.setItem('user',JSON.stringify(this.userdata))
                    localStorage.setItem('user',JSON.stringify(this.userdata))
                }
            },
        }).mount('#app');
        //順便提一下原生的方法 取得DOM.value > 輸入資料庫and localstorage > 用innerHTML渲染網頁 
    </script>


---第五課使用v-for將多筆資料渲染到網頁---

v-for這個屬性的功能類似使用for迴圈累積文字並渲染到網頁上，只是這個操作更直覺簡潔。
型態:
指定DOM上 v-for="自訂義名稱 in 資料路徑(陣列或物件)"
//這個就類似for in的方法 但還是有些不同
//v-for的原理是這樣的，它會掃過資料路徑的物件或陣列
//接著使用者就可以使用{{自訂義名稱.屬性}}(自訂義名稱代表物件或陣列內的值)將內容給呈現到畫面上
//使用者這邊只要輸入一次即可，當你在HTML的標籤上輸入一次{{}}，就會自動將資料路徑內的所有值都呈現在畫面上


多說無益，直接看範例:

先看script code
  <ul id="app">
        <li>
            <img src="./根元件.png" alt="" style="width: 50px;border: 1px solid;">
            <p>商品一</p>
        </li>
        <li v-for="i in products" :key="i.id" >
            <!-- 
                型態:v-for="自訂義名稱 in 資料路徑(物件/陣列) v-for會自動讀取指定路徑的所有內容"
                接著v-for要放到想要複製的區塊上，只要放上來子DOM也會一同執行for
                這邊補充key用意，是要讓每個渲染出來的區塊有唯一性，方便之後操作
            -->
            <img v-bind:src="i.url" alt="商品圖" style="width: 50px;border: 1px solid;">
            <!-- 因為會v-for會一一的複製指定DOM，所以子內容的v-bind也會跟著一一改變跟渲染 -->
            <p>{{i.name}}</p>
            <!-- 文字同上說明 -->
        </li>
    </ul>

    <script>
      
        const products = [//導入的資料
            {
                id:'1',
                name:'商品二',
                url:'https://chiyum.github.io/myPage/img/formalLogoNb.png'
            },
            {
                id:'2',
                name:'商品三',
                url:'https://chiyum.github.io/holdkibor/img/logo.png'
            },
        ];

        Vue.createApp({
            data(){
                return{
                    products:[],//先建立個空物件，等啟動後導入資料
                };
            },
            created(){
                this.products = products;//載入時導入外部資料
            },
            method:{

            }
        }).mount('#app');//綁定區塊

        //輸入完往HTML繼續

    </script>


補充:會使用key="iteam.id"是要補上唯一值，這在後面章節會介紹。


---v-if--- 

今天可以使用狀態來決定是否要顯示視窗

  Vue.createApp({
            data(){
                return{
                    products:[],//先建立個空物件，等啟動後導入資料
                    isShow:false
                };
            },
            created(){
                this.products = products;//載入時導入外部資料
            },
            method:{
                show(){
                    this.isShow = true;
                }
            }
        }).mount('#app');//綁定區塊


<button type="button" v-on:click="show">按鈕</buttom>

<ul v-if="isShow">//若isShow為true就會顯示，反之。
</ul>


ex.v-if="選項一||選項二" 可以使用邏輯運算子，以上述範例，其中一個選項回傳true，那if就會顯現

ex2.跟v-if很像的有v-bind:class=""
除了可以將要裝上的class貼上外，還可以使用狀態判斷的方法來決定是否要添加class
v-bind:class="{class名稱:路徑狀態}"//若路徑狀態回傳為false則不開啟，反之true則開啟class



---vue指令(directive)---
所謂指令就是v-if, v-model, {{}}等這些操作被稱為指令


指令又分為三個部分: 資料相關、渲染方法、事件綁定

1.資料相關:就是會操作到資料區塊的指令，如v-model

2.渲染方法:顧名思義就是渲染網頁相關，例如v-if, v-for, v-show

3.事件綁定: v-on @...等這些事件綁定的操作

雖然前面已經介紹過部分的操作了，但只不過是大略介紹，以下將會進行詳解。


ol.v-text and {{}}(Mastache)

v-text 與{{}}其實是一樣的效果
差別在於v-text是在指定標籤上渲染文字

{{}}則是在{{}}在哪，就在哪裡渲染


一般實戰來說用到{{}}的機率更多
但v-text有個好處就是可以隨著依附的標籤進行css的更動
範例:
<em v-text="name"></em>//如此v-text渲染出來的文字就會是em自帶的斜體

ol.v-html 

基本上與原生的innerHTML標籤是一樣的，給予標籤的字串後會自動判別標籤並將標籤轉為dom
範例:

data(){
    return{
        name:<p>測試文字</p>
    }
}

<div v-html="name"><div>//之後就會產生一個p標籤及"測試文字"的字串

不過基本上是不建議使用這個方式，因為會有XSS攻擊

ol.v-once 單次渲染
當我們只想要讓網頁在一開始的時候渲染，之後資料更動時不會跟著更動的話就可以使用v-once
範例:
<p v-once> {{ name }} <p>// v-once只需這樣寫在標籤上即可 如此不管後面資料怎麼變動，在標籤內的資料只會受到第一次渲染的影響，後續都不會再改變

    進階使用:

    樣板字面值:
    在{{}}中其實可以使用js的樣板字面值，與JS內運用完全一樣，只需要在{{}}加入``即可
    範例:
    {{`你好安安`}}//這樣的話並不會發生顯示{{`你好安安`}}的錯誤，而是會渲染你好安安這個純字串
    {{ `${name}對我說你好` }}//當然也可以插入變數，但是注意，${}內只能插入vue內的資料，在外部的資料是無法讀取的，會顯示undefind

    表達式:
    {{ name.toUpperCase() }}//亦可直接在{{}}內進行表達式 toUpperCase()的用法是原生JS 目的是將字串轉為大寫
    {{ `題目:1 + 1 = ` 1+1   }}//可以直接在{{}}內進行JS的運算 也是表達式的一種
    {{ isOpen?'早安': '午安' }}//更可以使用三元運算子

    呼叫函式:
    {{ say() }}//既然都可以使用表達式了，呼叫使用function當然也不再話下 這邊注意，不需要像外面呼叫一樣使用this，直接使用function即可

    顯示{{}}:
    假設說想要顯示{{}}，而不是要使用顯示資料的功能。那就在{{}}的標籤加入v-pre即可
    範例:
    <p v-pre>{{ name }}</p>  //會顯示{{ name }}



ol.v-for
v-for 可以用於物件or陣列，會掃過陣列、物件的所有值
型態:v-for = "自訂義名稱 in 指定陣列or物件"
此時的自訂義名稱就是每次跑過的值，假設今天有個範例是這樣的:


    let test = [
        {
            name:'小明'
        },
        {
            name:'杰倫'
        },
    ]

    <li v-for="iteam in test">
        {{ iteam.name }}//iteam就是每次跑過的物件，name就是每次跑過物件的屬性
    </li>

    除此之外，v-for在自訂義名稱還有個索引值 索引值就是陣列or物件的值的位置順序
    類似forEach(data,i){}其中data是內容，i是索引值
    型態:v-for = "(自訂義名稱,自訂義索引值) in 指定陣列or物件"
    按照上面的範例:


    <li v-for="(iteam,key) in test">
        {{key}} / {{ iteam.name }} //以第一個小明的物件來說明，小明所在的這個物件的索引值就是test[0];
    </li>

    注意事項:若今天是以物件跑回圈，那麼key會是屬性名稱。同樣以小明來說明，key就是name


    純數值迴圈:
    v-for除了帶陣列物件外，還可以使用數字
    型態:v-for = "自訂義名稱 in 數字"
    那麼自訂義名稱就會是數字1開頭一直跑到指定數字(含)結束
    範例:
     <li v-for="iteam in 5">
        {{ iteam }} //那麼iteam就會從1跑到5
    </li>

    觀念:
    每個v-for擁有同個父元素時，子元素必須要有獨特的key，重複的key會造成渲染錯誤
    甚麼叫渲染錯誤?而且可能會有人疑惑可是當沒有加上key時他還是照原本的順序跑耶，這個渲染錯誤是偶爾才會出現的bug嗎?

    其實不是。拿上面的例子來說:

    <li v-for="(iteam,key) in test">
        {{ iteam.name }} 
        <input type="text">//假設今天我在這邊輸入1234的字串
    </li>
    然後我再改變test的順序，讓小明在後
    那麼就算小明的文字被渲染到杰倫底下了，這個我輸入1234的字串依然會在原地。
    這說明甚麼?說明只是資料的順序調換了，網頁並沒有重新渲染，這個就是所謂的渲染錯誤。
    而為了讓input是綁定資料的就需要加上個key
    那key是甚麼?有人會是使用gettiem在原先的物件內創造個獨一無二的數字id，有人則是會用原本屬性就有的值，如小明跟杰倫就是不同的值
    這兩者都可以，只是要記住一點，這個值是得獨一無二的，若是有多個小明，那key就會重複。

    正確的輸入key:

    <li v-for="iteam in test" v-bind:key="iteam.name">
        {{ iteam.name }} 
        <input type="text">//假設今天我在這邊輸入1234的字串
    </li>

    
    v-for + template
    有時候會遇到一個狀況，我們需要在兩個不同的節點加入一筆資料，那該怎麼做?

    狀況範例:
    <table>
        <tr>
            <th rowspan="2">1</th>
            <td colspan="2">
            飯糰
            </td>
        </tr>
        <tr>
            <td>30</td>
        </tr>
    </table>

    可以看到2個tr為不同節點，若要在td內輸出資料，v-for好像沒辦法使用
    那此時就可使用template這個標籤:

     <table>
        <template v-for="iteam in test">
            <tr>
                <th rowspan="2">1</th>
                <td colspan="2">
                {{iteam.name}}
                </td>
            </tr>
            <tr>
                <td>{{iteam.money}}</td>
            </tr>
        </template>
    </table>

    如此父元素就會是template而非tr了
 



ol.v-if渲染判斷

    當我們渲染時是要有條件地進行渲染時，就需要用上v-if
    甚麼叫有條件?假設我今天要使用者點擊才會出現這就叫做有條件

    型態:<p v-if="屬性路徑"></p>
    //只要屬性路徑為true就會顯示，反之false則是消失 !!注意這邊是消失，這邊與v-bind:class{class:屬性路徑}的差別在於屬性路徑我們是設定class 而class只有隱藏並沒有消失
    
    v-if對應的是v-else。都有if了，沒else說不過去吧?
    v-else的邏輯與JS一樣，當if為false，那麼就渲染v-else

    範例:

    <p v-if="false">早安</p>
    <p v-else>午安</p>

    v-else-if
    看到這裡想必大家都知道還遺漏個else if。以下介紹個用法:

    Vue.createApp({
        data(){
            return{
                link:'小明'
            }
        }
    })

    <button type="button" v-on:click="link = '小明' "> 小明 </button>
    <button type="button" v-on:click="link = '小美' "> 小美 </button>
    <button type="button" v-on:click="link = '小如' "> 小如 </button>//這邊可以注意一下，v-on也可以這樣用，可以直接更改data的值。只要從HTML指定的話，都不需要加this
    
    <div v-if="link == '小明' ">小明吃牛排</div>//這邊可以看到，我們並非需要調動到data的資料，只需要回傳false or true的布林就可以操控v-if
    <div v-else-if="link == '小美' ">小美吃乾麵</div>
    <div v-else>小如吃漢堡</div>

    備註:v-if 跟v-for 不推薦一起使用在同一個標籤上 可能會造成一些錯誤 主要是因為v-if的權重比v-for更高
    若有這個需求可以搭配template 讓template跑for,if用於要隱藏的元素
    
    v-show
    v-if跟v-show放在同一章解說是因為兩者差異不多，差別在於v-show若為false 則是用dispaly:none。與v-if是直接刪除節點差別在此


ol.v-bind 屬性
    v-bind可以將資料輸入到屬性中。如src, data-*, class, id等 基本上所有的HTML標籤都可以套用
    型態:v-bind:屬性="屬性路徑"
    簡寫模式: :屬性 //簡寫模式很簡單，直接去除v-bind即可

    v-bind同樣也可以搭配v-for使用

    v-bind亦可動態的加入屬性

    <input type="text" :[type]]>
    <input type="button" value="切換" v-on:click=" type = type === 'disabled' ? 'readonly':'disabled' ">
    //這段v-on的邏輯是 資料路徑(type)的值 = 如果資料路徑(type) === disabled的話返回readonly給資料路徑，否則返回disabled給資料路徑
    //首先 判斷右邊type這個資料值是否為disabled，是的話就返回readonly回來，否的話就返回disabled
    //接著返回到右邊type的值再賦予給type
    //為甚麼不使用一個type就好了呢?type === 'disabled' 是在比對而已，後面的三元運算子雖然會回傳，但並不會回傳在type上
    //所以前面多一個 = 是為了要將回傳的值賦予到type上面

    備註:disabled是禁用input, readonly則是只能讀不能寫



ol.樣式切換 




ol.修飾符(modifiers)
修飾符基本上來說就是扶助指令運作

ol.縮寫
vue指令其實可以使用@縮寫來替代
如:
v-on:click="click"
可以縮寫成:
@click="click"