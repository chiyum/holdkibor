
JS前置觀念

---語法糖---:
語法糖只是讓程式碼看起來更簡潔，與原先並不會有使用上的差異。
在物件使用屬性都需要加分號:
但在ES6以後
若是function則直接輸入function的呈述式即可
範例:
let d ='d'
let obj = {
    a:'a',
    fn(){
        console.log('i')
    },
    b:'b',
    d,
}

除了function外，物件也可以直接代入，那麼屬性名稱就等於變數名稱，屬性值等於變數值

陣列串接---
以往來說會是 c = a陣列.concat(b陣列)
但ES6可以使用更省事的方法

C陣列 =[...a陣列,...b陣列]//...的方法是將陣列內的物件取出並排列
若沒有使用...的話，c陣列會是包住a陣列及b陣列

同時物件也可以用此方法新增

let a = {
    a:'a',
    b:'b',
}

let c ={
    ...a
}

//類陣列轉為純陣列也可以使用相同方法


---預設值---
現在參數也可以帶入預設值，假設今天有兩個參數，但使用者只代入一個那很有可能會出現bug
let fn = (a,b)=>{
    return a + b
};

fn(1,2) //3
fn(1) //NaN

傳統的方法避免的方法是
let fn = (a,b)=>{
    if(!b){b=2}
    return a + b
};

現在只需要使用預設值就可以避免錯誤

let fn = (a,b = 2)=>{
    return a + b
};


---this指向---

simple call

範例:
var someone = '全域';
function callsomeone(){
    console.log(this.someone);
};

callsomeone();//這個就叫做simple call 當前面沒有任何物件，就叫做simple call 又稱為簡易呼叫

而this的指向跟怎麼定義它沒有關聯而是呼叫的方法。假設使用simple call 就是呼叫全域
但若是使用object.callsomeone(),那就會指向前面的object內的內容。


var obj = {
    someone:'物件',
    callsomeone //將上面宣告的函式放進來
};

obj.callsomeone()//顯示物件


物件內的物件呼叫

var obj2 = {
    someone:'物件外',
    callsomeone //將上面宣告的函式放進來
    obj = {
        someone:'物件內',
        callsomeone //將上面宣告的函式放進來
    };
};

obj2.obj.callsomeone()//顯示物件內


常見陷阱


var obj = {
    someone:'物件',
    fn(){
        callsomeone();//它其實也算simple call 但平常並不會這樣使用
        //注意這裡，callsomeone前面並沒有任何物件
    }
};

obj.fn()//顯示全域


var obj = {
    someone:'物件4',
    fn(){
        setTimeout(()=>{
            console.log(this.someone)
        });
    },
};

obj.fn()//顯示全域 原因是setTimeout是在全域下執行而非object

補充:若是在事件觸發後，this通常代表觸發的元素本身
總結:this的指向跟調用(呼叫)的方法有關



---箭頭函式---

特點:除了語法糖外，特點就是它沒有自己的this
範例:
let obj = {
    callName:function(){
        console.log(this);//顯示物件本身
        setTimeout(()=>{
            console.log(this)//在傳統函式中會指向window，但若是使用箭頭函式則會跟著父層指向相同，在這個範例中也就是指向物件。
        }),
    }
}

obj.callName();


常見陷阱
let name = 全域;
let obj = {
    name:'小明',
    callName:()=>{
        console.log(name);
    }
}

obj.callName()//顯示全域。與傳統函式不同，前面說到箭頭函式會跟著父層指向相同。但在這個範例中obj內的callname外層並沒有函式，準確地來說它的外層函式就是全域，所以這個this就指向全域。


let name = 全域;
let obj = {
    name:'小明',
    callMe(){
        let callName = ()=>{
            console.log(this.name);
        };
        callName();
    },
};

obj.callMe()//顯示小明 因為在callname外層的函式是傳統函式，也就是指向物件本身，而箭頭函式則是跟隨外層函式來定義this。理所當然地也就跟著callMe的this定義。




---元件結構(關注點分離/MVVM)---
所謂元件結構就是將一個功能所運用到的所有內容都放在一個物件中，包含函式、儲存的資料等
依所需情況調用及觸發，每一個屬性都各自獨立但卻又相關，所以稱為關注點分離。
基本的元件結構有:
1.資料
2.方法、觸發器
3.生命週期


const click ={
    data:[],
    function(){

    },//若是要渲染HTML結構，盡量在一個function內
    init(){//稱為生命週期，一開始載入後所要執行的函式
        this.function
    }
}


範例:
const click ={
    data:[],
    fn(){
        console.log('安安你好')
    },
    init(){//稱為生命週期，一開始載入後所要執行的函式，通常是開發者自訂義
        this.fn();
    },
}
click.init()


---物件、陣列、函式傳參考---

在我們創立一個物件的時候，其實並非是像純值(如字串、布林)一樣將值賦予到變數上，而是將物件的位置傳給變數。

當我們新增一個物件就相當於在網頁的儲存區建立物件。而當我們要取用物件時就會自動導向物件的路徑。
好比賦予變數物件，讓我們從以下範例解釋。

let a = {x:1};
//在這操作中瀏覽器共做了兩件事
1.在瀏覽器的儲存區中新增{x:1}的物件
2.將儲存區的物件路徑賦予到a

所以當我們使用console.log(a)時，其實是從a這個路徑瀏覽{x:1}這個物件。
由此可知，當我們同時賦予兩個變數一樣的物件時，他們的路徑都是一樣的，其中一個物件屬性及值更動，另一個也會同步。

let a= {x:1};

let b = a;

b.x = '2';

console.log(a.x)//顯示2

須知注意:
但是我們得注意，當我們又新增了一個{}時，就等同於又新增了一個路徑，就算裡面內容相同也並非是同一個路徑。
範例:

let a = {x:1};

let b = {x:1};

console.log(a===b)//回傳false


淺深層複製

當我們要複製物件內容但又不共用同一個參考路徑時該怎麼做呢?
有兩個方法，淺層及深層。

淺層:
淺層就是複製物件內的值與屬性，但屬性的值內若有物件，那這個物件還是共用同個路徑的。
let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = Object.assign({},a);//方法一
let c = {...a}//方法二

//按照上面的範例來說，a跟b還是共用同一個x物件路徑


深層:
深層拷貝就不會有共用路徑的問題，而是會創造一個新的物件
原理很簡單，就是將物件內的所有內容都轉為字串，再從字串轉為物件。


let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = JSON.parse(JSON.stringify(a));



promise

promise 嚴格來說是為了解決非同步語法難以建構以及管理的問題。
簡單來說就是在所有資料都處理好以後，再接續執行下一步。
常用於AJAX，當處理完所有傳送及取得的程序以後，再來接續進行下一步的渲染等動作。
經典使用promise的AJAX處理套件為axios

promise會先建立一個建構式

const promise_Set = (status)=>{//套入狀態
    return new Promise(resolve,reject)=>{
        setTimeout(()=>{//讓此程式碼最後執行
            if(status){//當狀態為true時
                resolve('成功')//resolve的參數代入成功
            }else{
                reject('失敗')//reject的參數代入失敗
            }
        })
    }
}

promise_Set(true);//狀態套入
    .then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
    })
    .catch((rej)=>{
        console.log(rej)//同上會是reject的('失敗')
    })


promise串接
promise_Set(true)
.then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
        return promise_Set(true)//當在此使用return時，下一個.then/.catch就會是此promise_Set(true)所回傳的結果
    })
.then((res)=>{
    console.log(res);
})

元件中使用promise

const a = {
    data:{}
    init(){//這邊若是要用this需要使用傳統函式，因為箭頭函式this是隨著父層函式的this而定義
        promise_Set(true)
        .then(res=>{
            this.data.res = res;//在data元件中新增res的屬性及值
        })
        .catch((rej)=>{
            alert('傳送失敗');
        })
    }
}

a.init();



使用axios搭配promise

axios.get('url')//url代表連接網址
    .then((res)=>{
        console.log(res)//res回傳的資料
    }) //axios內建就有promise所以可以不用建構直接使用
    .catch((rej)=>{
        console.log(rej.response)//回傳失敗的資料
        console.log('串接失敗')
    })

post方法補充: axios.post('url',{傳送的內容});



---ES模組---

ES步驟:

1.於模組化的script上加上type="module"

2.匯出匯入觀念
匯入跟匯出有很大的關連，所以我們先說明匯出。

匯出(js)//僅在js進行

匯出又分成預設跟具名匯出

預設匯出: export default
//每個檔案只能有一個


具名匯出: export const xxx = ...
//每個檔案有多個
而匯出可以同時匯出具名及預設



匯入(html,js)//在html or js進行
既然有預設匯出，自然也又預設匯入及具名匯入

預設匯入 import 自訂名稱 from 檔案

具名匯入{具名名稱} from 檔案


匯出入方法

匯出用法
1.新建個匯出JS檔案

2.填上匯出程式碼
export default {//默認
    ...程式碼
}

export const abc{//具名
    ...程式碼
}

匯入用法

1.在要匯入的檔案中導入

import fn from './...路徑'//默認

import{abc} from './all.js'


此時fn就等於你寫在匯入JS檔案內的那一個function or obj or ary or 變數

2.使用
接下來就看你是匯入甚麼，就照原先的方法使用即可。



匯入有兩種方式:
單一匯入、全部匯入

比較建議單一匯入，因為全部匯入錯誤難以發現
單一匯入就是個別匯入
全部顧名思義就是不管有多少個匯出，一次接受一次匯入


單一:

inport {a,b} from '路徑'
//匯入a及b匯出


全部:

import * as all from '路徑'
//as 是賦予到一個變數的名稱上 all就是那個物件的名稱


sideEffect.js(沒有包含匯出的檔案):
也就是沒有使用export的內容，其實也可以進行匯入

inport '路徑' //直接導入即可



實戰:

先說明每一個 type="module"的作用域是各自獨立的。
也就是說假設有兩個script都有綁type="module"並且有匯入。
但我在第一個匯入的檔案，在第二個是無法使用的


ESM
網路上找的到的CDN的網址上若有ESM字樣基本上都可以使用import的方式匯入

inport {} from 'CDN網址'

直接使用




觀念都理解了，正式進入vue的教學。

首先vue的概念就是對應元件結構
{
    data:[儲存的資料]
    render()//渲染HTML的function(事件觸發)
    init()//載入時所執行的動作(生命週期)
    //假設今天要使用這個元件結構，就從呼喊init這個function就會執行。
}

只是vue都幫你把以上的事情都做好了，基本上只需要在指定標籤加上指定屬性，vue就會幫你做渲染


vue 環境設置
於瀏覽器安裝vue開發者工具套件
網址:https://headwayapp.co/vue-js-devtools-changelog/timeline-and-api-166716
//注意一定要從這安裝beta版本，可能是設定問題正式版沒辦法使用。

在開發者工具中可以找到vue的介面
    介面左邊會有一個根元件，點選，右邊會有data的資料庫。
    後面開發的話都會以這個根元件為主，階梯式的呈現在介面上

載入vue cdn放在head內 //這邊要注意版本，目前教學為3

<script src="https://unpkg.com/vue@next"></script>



---第一課定義元件---
型態:
Vue.createApp({//定義元件 也就是vue的起手式，類似jq的$(doc).ready

  data(){
    return{
      //資料庫
    }
  }
}).mount('DOM')// 執行元件    
//這邊的mount是將這個元件給綁定到指定的DOM


範例及解說:
Vue.createApp({//使用vue時都會先使用createApp，上面有提到類似JQ的ready
  data() {//定義一個資料儲存區 需注意的點是這邊的data是一個函式，資料是用return的方式回傳。這個作法的用意是使用原生JS內件的proxy功能，讓物件內的其他函式可以使用this.屬性調用
    return {
      counter: 0,
      text: '這裡有一段文字123'
    }
  }
}).mount('#app')//到mount之前，元件及資料儲存的定義就已經完成，mount則是綁定DOM


---第二課完整vue定義及事件--- 

型態說明:

<div> {{value}} </div>//顯示123 這邊是輸入資料路徑。
簡單的說明一下資料路徑
當我們需要調用data()這個資料庫內的路徑時，data所回傳的就是一個物件，並不需要使用data.value的方式呼叫，因為當data()將{}回傳時，{}就已經是app這個物件內的值了。
總得來說就是只需要使用要調用時只需要使用return{}物件內的值就可以了。
假設你物件內的值是物件，你要取用物件內的物件，就使用原生js的物件呼叫方法即可。


<input type="buttom" v-on:click="click"> //當DOM要觸發methods裡面的方法時，於標籤內輸入v-on:觸發事件="function" ex.這邊不需要再加個中括號了()

const app = {
    data(){//資料儲存區 ex.這邊一定要是函式
        return{
            value:'123'//通過{{屬性}}，可以將值給渲染到瀏覽器上
        }
    }
    created(){生命週期 更改data內容
        this.value = '456'//這邊之所以抓地到data的值是因為使用了return，return後的內容就會被proxy攔截。簡單來說就是return後內容父層抓地到
    }
    methods:{//方法(事件觸發) ex.會是一個物件

        click(){
            console.log('安安');
        }        
    }
}

事件型態:
HTML
<div v-on:事件="function名稱">按鈕</div>
//因為已經綁定在區塊中了，所以不需要再使用物件方法呼叫
methods.click (X)
click (O)//不需要加入()

補充:v-on事件有:
click 觸發
keyup 鍵盤  keyup這邊比較特殊,因為鍵盤有多個按鍵，所以keyup的v-on型態是這樣: v-on:keyup.enter ="function"
//其中enter為按鍵的縮寫，只要是按下enter都會觸發。
//縮寫類型有 .enter, .tab, .delete(包含刪除跟退格鍵), .esc, .space, .up, .down, .left(滑鼠左鍵), .right(滑鼠右鍵)
//按鍵縮寫好像也能直接輸入key代碼(待確認) 
input 只要input的值有改變就會觸發 與原生用法差不多(change,input)


第三課 雙向綁定

v-model 綁定到資料輸入區並與其同步，只要資料輸入區改變or v-model的內容改變，兩者都會同步 (綁定一)

當定義一個元件以後，若是要將input取得的資料輸入進資料庫需要使用v-model
相當於原生.value /JQ.val()的概念。
//亦可取得select的value

型態:
HTML
<input v-model="資料庫物件名稱.屬性名稱">//已經綁定在區塊內，所以就直接使用資料路徑即可



v-bind: 綁定輸出到HTML屬性上 (綁定二)
v-bind可以資料酷的輸出到指定的HTML屬性上
型態:
HTML
<img bind:src="資料庫名稱.屬性名稱"

稱為雙向綁定的原因是兩者已經同步，當有一方改變，另一方也會同步改變。



第四課 導入外部資料進資料區

說明:

let obj = {//外部資料 不管外部資料是甚麼形式。陣列 or 物件等都一樣可以導入
    a:123,

}

const = add{
    data(){
        return{
            data:{
                
            }
        }
    },
    created(){//當我們要使用外部資料進行渲染時，就在生命週期這邊導入外部資料，這邊在一開始載入vue的時候就會執行
        this.data = obj//如此在載入vue時，外部的資料就會導入到指定的路徑
        //這邊要注意this本身就已經代表data，所以這個data是return物件內的data屬性喔
    }
    method:{

    }
}

Vue.createApp(add).mount('#id')

---第五課 將資料傳入資料庫---
因為v-model的特性是雙向綁定，所以假設我們每一次觸發事件都要新增一筆不一樣的資料要怎麼處理呢?
範例解說如下:

 <div id="app">
        帳號:
        <input type="text" v-model="temp.account">
        <!-- v-model有個特點 假設指定路徑內沒有該屬性，那會自動新增這個屬性 -->
        <br>
        密碼:
        <input type="text" v-model="temp.password">
        <br>
        <button type="button" v-on:click="add_userdata">送出</button>
        <!-- 這邊type要使用button 否則預設定義是submit -->
        導入的帳密:{{temp.account}},{{temp.password}}
        <br>
        userdata內容:{{userdata}}
    </div>
    <script>
       Vue.createApp({
            data(){
                return{
                    userdata:[],
                    temp:{}
                }
            },
            created(){
                this.userdata = JSON.parse(localStorage.getItem('user'));//從local端取得資料
            },
            methods:{
                add_userdata(){
                    this.temp.id = new Date().getTime();//此行目的產生唯一性id 從這邊也可以有v-model的特效，物件內沒該屬性會自動新增 就跟原生JS一樣
                    this.userdata.push(this.temp);//將目前temp的內容上傳至userdata這個陣列內
                    this.temp = {};//清空
                    this.update();//輸入至local端
                },
                update(){
                    // localStorage.setItem('user',JSON.stringify(this.userdata))
                    localStorage.setItem('user',JSON.stringify(this.userdata))
                }
            },
        }).mount('#app');
        //順便提一下原生的方法 取得DOM.value > 輸入資料庫and localstorage > 用innerHTML渲染網頁 
    </script>


---第五課使用v-for將多筆資料渲染到網頁---

v-for這個屬性的功能類似使用for迴圈累積文字並渲染到網頁上，只是這個操作更直覺簡潔。
型態:
指定DOM上 v-for="自訂義名稱 in 資料路徑(陣列或物件)"
//這個就類似for in的方法 但還是有些不同
//v-for的原理是這樣的，它會掃過資料路徑的物件或陣列
//接著使用者就可以使用{{自訂義名稱.屬性}}(自訂義名稱代表物件或陣列內的值)將內容給呈現到畫面上
//使用者這邊只要輸入一次即可，當你在HTML的標籤上輸入一次{{}}，就會自動將資料路徑內的所有值都呈現在畫面上


多說無益，直接看範例:

先看script code
  <ul id="app">
        <li>
            <img src="./根元件.png" alt="" style="width: 50px;border: 1px solid;">
            <p>商品一</p>
        </li>
        <li v-for="i in products" :key="i.id" >
            <!-- 
                型態:v-for="自訂義名稱 in 資料路徑(物件/陣列) v-for會自動讀取指定路徑的所有內容"
                接著v-for要放到想要複製的區塊上，只要放上來子DOM也會一同執行for
                這邊補充key用意，是要讓每個渲染出來的區塊有唯一性，方便之後操作
            -->
            <img v-bind:src="i.url" alt="商品圖" style="width: 50px;border: 1px solid;">
            <!-- 因為會v-for會一一的複製指定DOM，所以子內容的v-bind也會跟著一一改變跟渲染 -->
            <p>{{i.name}}</p>
            <!-- 文字同上說明 -->
        </li>
    </ul>

    <script>
      
        const products = [//導入的資料
            {
                id:'1',
                name:'商品二',
                url:'https://chiyum.github.io/myPage/img/formalLogoNb.png'
            },
            {
                id:'2',
                name:'商品三',
                url:'https://chiyum.github.io/holdkibor/img/logo.png'
            },
        ];

        Vue.createApp({
            data(){
                return{
                    products:[],//先建立個空物件，等啟動後導入資料
                };
            },
            created(){
                this.products = products;//載入時導入外部資料
            },
            method:{

            }
        }).mount('#app');//綁定區塊

        //輸入完往HTML繼續

    </script>


補充:會使用key="iteam.id"是要補上唯一值，這在後面章節會介紹。


---v-if--- 

今天可以使用狀態來決定是否要顯示視窗

  Vue.createApp({
            data(){
                return{
                    products:[],//先建立個空物件，等啟動後導入資料
                    isShow:false
                };
            },
            created(){
                this.products = products;//載入時導入外部資料
            },
            method:{
                show(){
                    this.isShow = true;
                }
            }
        }).mount('#app');//綁定區塊


<button type="button" v-on:click="show">按鈕</buttom>

<ul v-if="isShow">//若isShow為true就會顯示，反之。
</ul>


ex.v-if="選項一||選項二" 可以使用邏輯運算子，以上述範例，其中一個選項回傳true，那if就會顯現

ex2.跟v-if很像的有v-bind:class=""
除了可以將要裝上的class貼上外，還可以使用狀態判斷的方法來決定是否要添加class
v-bind:class="{class名稱:路徑狀態}"//若路徑狀態回傳為false則不開啟，反之true則開啟class



---vue指令(directive)---
    所謂指令就是v-if, v-model, {{}}等這些操作被稱為指令


    指令又分為三個部分: 資料相關、渲染方法、事件綁定

    1.資料相關:就是會操作到資料區塊的指令，如v-model

    2.渲染方法:顧名思義就是渲染網頁相關，例如v-if, v-for, v-show

    3.事件綁定: v-on @...等這些事件綁定的操作

    雖然前面已經介紹過部分的操作了，但只不過是大略介紹，以下將會進行詳解。


ol.v-text and {{}}(Mastache)

    v-text 與{{}}其實是一樣的效果
    差別在於v-text是在指定標籤上渲染文字

    {{}}則是在{{}}在哪，就在哪裡渲染


    一般實戰來說用到{{}}的機率更多
    但v-text有個好處就是可以隨著依附的標籤進行css的更動
    範例:
    <em v-text="name"></em>//如此v-text渲染出來的文字就會是em自帶的斜體

ol.v-html 

    基本上與原生的innerHTML標籤是一樣的，給予標籤的字串後會自動判別標籤並將標籤轉為dom
    範例:

    data(){
        return{
            name:<p>測試文字</p>
        }
    }

    <div v-html="name"><div>//之後就會產生一個p標籤及"測試文字"的字串

    不過基本上是不建議使用這個方式，因為會有XSS攻擊

ol.v-once 單次渲染
    當我們只想要讓網頁在一開始的時候渲染，之後資料更動時不會跟著更動的話就可以使用v-once
    範例:
    <p v-once> {{ name }} <p>// v-once只需這樣寫在標籤上即可 如此不管後面資料怎麼變動，在標籤內的資料只會受到第一次渲染的影響，後續都不會再改變

    進階使用:

        樣板字面值:
            在{{}}中其實可以使用js的樣板字面值，與JS內運用完全一樣，只需要在{{}}加入``即可
            範例:
            {{`你好安安`}}//這樣的話並不會發生顯示{{`你好安安`}}的錯誤，而是會渲染你好安安這個純字串
            {{ `${name}對我說你好` }}//當然也可以插入變數，但是注意，${}內只能插入vue內的資料，在外部的資料是無法讀取的，會顯示undefind

        表達式:
            {{ name.toUpperCase() }}//亦可直接在{{}}內進行表達式 toUpperCase()的用法是原生JS 目的是將字串轉為大寫
            {{ `題目:1 + 1 = ` 1+1   }}//可以直接在{{}}內進行JS的運算 也是表達式的一種
            {{ isOpen?'早安': '午安' }}//更可以使用三元運算子

        呼叫函式:
            {{ say() }}//既然都可以使用表達式了，呼叫使用function當然也不再話下 這邊注意，不需要像外面呼叫一樣使用this，直接使用function即可

        顯示{{}}:
            假設說想要顯示{{}}，而不是要使用顯示資料的功能。那就在{{}}的標籤加入v-pre即可
            範例:
            <p v-pre>{{ name }}</p>  //會顯示{{ name }}



ol.v-for
    v-for 可以用於物件or陣列，會掃過陣列、物件的所有值
    型態:v-for = "自訂義名稱 in 指定陣列or物件"
    此時的自訂義名稱就是每次跑過的值，假設今天有個範例是這樣的:


        let test = [
            {
                name:'小明'
            },
            {
                name:'杰倫'
            },
        ]

        <li v-for="iteam in test">
            {{ iteam.name }}//iteam就是每次跑過的物件，name就是每次跑過物件的屬性
        </li>

        除此之外，v-for在自訂義名稱還有個索引值 索引值就是陣列or物件的值的位置順序
        類似forEach(data,i){}其中data是內容，i是索引值
        型態:v-for = "(自訂義名稱,自訂義索引值) in 指定陣列or物件"
        按照上面的範例:


        <li v-for="(iteam,key) in test">
            {{key}} / {{ iteam.name }} //以第一個小明的物件來說明，小明所在的這個物件的索引值就是test[0];
        </li>

        注意事項:若今天是以物件跑回圈，那麼key會是屬性名稱。同樣以小明來說明，key就是name


    純數值迴圈:

        v-for除了帶陣列物件外，還可以使用數字
        型態:v-for = "自訂義名稱 in 數字"
        那麼自訂義名稱就會是數字1開頭一直跑到指定數字(含)結束
        範例:
         <li v-for="iteam in 5">
            {{ iteam }} //那麼iteam就會從1跑到5
        </li>

        觀念:
        每個v-for擁有同個父元素時，子元素必須要有獨特的key，重複的key會造成渲染錯誤
        甚麼叫渲染錯誤?而且可能會有人疑惑可是當沒有加上key時他還是照原本的順序跑耶，這個渲染錯誤是偶爾才會出現的bug嗎?

        其實不是。拿上面的例子來說:

        <li v-for="(iteam,key) in test">
            {{ iteam.name }} 
            <input type="text">//假設今天我在這邊輸入1234的字串
        </li>
        然後我再改變test的順序，讓小明在後
        那麼就算小明的文字被渲染到杰倫底下了，這個我輸入1234的字串依然會在原地。
        這說明甚麼?說明只是資料的順序調換了，網頁並沒有重新渲染，這個就是所謂的渲染錯誤。
        而為了讓input是綁定資料的就需要加上個key
        那key是甚麼?有人會是使用gettiem在原先的物件內創造個獨一無二的數字id，有人則是會用原本屬性就有的值，如小明跟杰倫就是不同的值
        這兩者都可以，只是要記住一點，這個值是得獨一無二的，若是有多個小明，那key就會重複。

        正確的輸入key:

        <li v-for="iteam in test" v-bind:key="iteam.name">
            {{ iteam.name }} 
            <input type="text">//假設今天我在這邊輸入1234的字串
        </li>


        v-for + template
        有時候會遇到一個狀況，我們需要在兩個不同的節點加入一筆資料，那該怎麼做?

        狀況範例:
        <table>
            <tr>
                <th rowspan="2">1</th>
                <td colspan="2">
                飯糰
                </td>
            </tr>
            <tr>
                <td>30</td>
            </tr>
        </table>

        可以看到2個tr為不同節點，若要在td內輸出資料，v-for好像沒辦法使用
        那此時就可使用template這個標籤:

         <table>
            <template v-for="iteam in test">
                <tr>
                    <th rowspan="2">1</th>
                    <td colspan="2">
                    {{iteam.name}}
                    </td>
                </tr>
                <tr>
                    <td>{{iteam.money}}</td>
                </tr>
            </template>
        </table>

        如此父元素就會是template而非tr了
 



ol.v-if渲染判斷

    當我們渲染時是要有條件地進行渲染時，就需要用上v-if
    甚麼叫有條件?假設我今天要使用者點擊才會出現這就叫做有條件

    型態:<p v-if="屬性路徑"></p>
    //只要屬性路徑為true就會顯示，反之false則是消失 !!注意這邊是消失，這邊與v-bind:class{class:屬性路徑}的差別在於屬性路徑我們是設定class 而class只有隱藏並沒有消失
    
    v-if對應的是v-else。都有if了，沒else說不過去吧?
    v-else的邏輯與JS一樣，當if為false，那麼就渲染v-else

    範例:

    <p v-if="false">早安</p>
    <p v-else>午安</p>

    v-else-if
    看到這裡想必大家都知道還遺漏個else if。以下介紹個用法:

    Vue.createApp({
        data(){
            return{
                link:'小明'
            }
        }
    })

    <button type="button" v-on:click="link = '小明' "> 小明 </button>
    <button type="button" v-on:click="link = '小美' "> 小美 </button>
    <button type="button" v-on:click="link = '小如' "> 小如 </button>//這邊可以注意一下，v-on也可以這樣用，可以直接更改data的值。只要從HTML指定的話，都不需要加this
    
    <div v-if="link == '小明' ">小明吃牛排</div>//這邊可以看到，我們並非需要調動到data的資料，只需要回傳false or true的布林就可以操控v-if
    <div v-else-if="link == '小美' ">小美吃乾麵</div>
    <div v-else>小如吃漢堡</div>

    備註:v-if 跟v-for 不推薦一起使用在同一個標籤上 可能會造成一些錯誤 主要是因為v-if的權重比v-for更高
    若有這個需求可以搭配template 讓template跑for,if用於要隱藏的元素
    
    v-show
    v-if跟v-show放在同一章解說是因為兩者差異不多，差別在於v-show若為false 則是用dispaly:none。與v-if是直接刪除節點差別在此


ol.v-bind 屬性
    v-bind可以將資料輸入到屬性中。如src, data-*, class, id等 基本上所有的HTML標籤都可以套用
    型態:v-bind:屬性="屬性路徑"
    簡寫模式: :屬性 //簡寫模式很簡單，直接去除v-bind即可

    v-bind同樣也可以搭配v-for使用

    v-bind亦可動態的加入屬性

    <input type="text" :[type]]>
    <input type="button" value="切換" v-on:click=" type = type === 'disabled' ? 'readonly':'disabled' " v:bind:disabled="true or flase">//除了資料路徑外，還可以使用表達式 布林值來決定屬性是否存在
    //這段v-on的邏輯是 資料路徑(type)的值 = 如果資料路徑(type) === disabled的話返回readonly給資料路徑，否則返回disabled給資料路徑
    //首先 判斷右邊type這個資料值是否為disabled，是的話就返回readonly回來，否的話就返回disabled
    //接著返回到右邊type的值再賦予給type
    //為甚麼不使用一個type就好了呢?type === 'disabled' 是在比對而已，後面的三元運算子雖然會回傳，但並不會回傳在type上
    //所以前面多一個 = 是為了要將回傳的值賦予到type上面

    備註:disabled是禁用input, readonly則是只能讀不能寫
    



ol.樣式切換 v-bind:class運用
    最基本的使用方式有兩種:


    data(){
        return{
            class:'className',//這邊class以字串型式
            isShow:false,//這個屬性(key)的值為布林值
        }
    }

    1.搭配資料庫給予class
    範例:
    <p v-bind:class="class"></p>//這邊class為資料庫中的路徑
    如此當vue渲染這個標籤時就會套用指定路徑的class

    2.依照布林值選擇觸發與否
    範例:
    <p v-bind:class="{className:isShow}"></p>
    //這邊className則是class的名稱 isShow則是布林值
    //因為我isShow是true所以會套用這個class
    //ex.className就是屬性(key),值是布林值但也可以使用判斷式
    //這邊須注意，這邊的className是不能從資料庫取得的，只能輸入你所命名的class名稱

        進階使用:
        上面的介紹是使用物件方式來選擇是否套用class，但其實也有陣列的方式。
        不過物件方式還沒完全介紹完，這邊先介紹物件的部分。
        
            套用多個class:
            既然是物件了，那當然可以擁有多個key與值
            範例:
            <p v-bind:class="{className:isShow,className2:isShow2}"></p>
            //兩個class可以同時使用同個布林值路徑也可以不同。


        className若有 "-"這個文字:

        我們在:class套入class名稱的時候，class是不可以有-這個名稱的。
        這是因為我們套入的是物件，若要解決這個方式就是將key值變為字串就可以到解決。
        範例:
         <p v-bind:class="{'class-Name':isShow}"></p> 


        多個class放在同一個物件中:
        當你有多個class想要放在同一個標籤，卻又覺得在標籤內的屬性太長了怎麼辦?
        這時就可以將class給套入物件中

        data(){
            return{
                objClass:{
                    'class-Name':true,//無法使用資料路徑的布林值
                    className:fasle,//但可以直接輸入判斷式，若有需求就直接在mathods使用this.objClass.className = false or true 改變即可
                }
            }
            change(){
                this.data.box = this.data.box ? false : true;//這邊使用toggle的方式
            }
        }

        <p v-bind:class="objClass"></p>//直接將物件名稱帶進來即可 


        陣列寫法:
        如果說物件方式是使用判斷式來選擇是否要套用class，那陣列方式就是可以選擇套用多個class
        範例:
        <p v-bind:class="[className,className2,className3]"></p>//這邊className就是你所命名的class名稱
        效果就跟原生的class="className className2 className3"是一樣的效果
        當然也可以使用在data資料庫中寫好陣列並直接將陣列路徑套用到:class=""中即可。
        //這邊與物件一樣，差別在物件形式與陣列形式而已，就不做示範。


        操作行內樣式(style):
        操作style跟class的方式其實觀念是差不多的，只有操作上有些許差異
        操作方式有三種:

        
        1.在標籤上撰寫:
        上面所說過因為我們套入的是物件，所以不能有"-"這個符號，所以我們在寫style時，若原先的css文字中有"-"。
        那麼我們必須使用小駝峰的方式撰寫。
        甚麼是小駝峰?拿background-color來說，就是抽掉"-"，並在原先-後的第一個英文數字改成大寫
        background-color = backgroundColor 
        範例:
        <p v-bind:style="{backgroundColor:'red'}"></p>//記得這邊值是字串
        //key是代入style的屬性:值是代入相對應的值


        2.從資料取得物件
        style同樣可以從資料路徑中取得，在資料路徑中使用key與值的方式與在標籤上撰寫是一樣的，必須使用小駝峰形式
        範例:
        data(){
            return{
                objStyle:{
                    backgroundColor:'red',
                    fontSize:'12px'
                },
            };
        },


        <p v-bind:style="objStyle"></p>//記得這邊值是字串

        3.陣列方式撰寫style:
        其實使用陣列方式撰寫style，就是將上面撰寫的物件方式給加到陣列內套用而已
        範例:
        <p v-bind:style="[objStyle,{backgroundColor:'black',},objStyle2]"></p>//記得這邊值是字串


ol.資料綁定v-model 與表單:
    v-model在對應每個input type所產生的效果是不一樣的，以下我們來一一介紹:
    
    1.type="text"類型 不管是password 還是search類型，只要是與text相同的都是這個種類:
        這類綁定v-model的話，不管是資料庫還是標籤兩邊的資料更動是同步的
        範例:
        data(){
            return{
                text:'',
                checkbox:false,
                checkbox2:''
            }
        }

        <input type="text" v-model="text">
        //如此只要input輸入文字，資料庫那邊也會更新。
        //若資料庫刪除文字，input也會跟著刪除。

    2.綁定到checkbox(複選框)時:
        如果是綁定單一(單選)checkbox的話，當使用者點選時會回傳true，反之則是false


        <input type="checkbox" v-model="checkbox">//套用上面的data資料庫

        <p>{{ checkbox ? 答對了: 答錯了 }}</p>//通過三元運算子呈現不同的字串內容

    3.checkbox單選延伸:
        如同上面的結果，除了使用三元運算子以外，還有另一種用法
        
        
        <input type="checkbox" v-model="checkbox2" true-value="答對了"  false-value="答錯了">邏輯是這樣的，當checkbox回傳true時，回傳給資料庫checkbox2的值是true-value的內容，反之。

        <p>{{ checkbox2}}</p>//通過三元運算子呈現不同的字串內容


    4.checkbox複選使用:
        checkbox複選框的使用就需要使用到value這個屬性
        以下以範例來說明:

        data(){
            return{
                chose_ary:[],//複選使用是綁定到到陣列
            }
        }

        <input type="checkbox" value="標籤一" v-model="chose_ary">
        <input type="checkbox" value="標籤二" v-model="chose_ary">
        <input type="checkbox" value="標籤三" v-model="chose_ary">
        //三個是綁定同一個陣列，所以選擇以後value會加入陣列內

        {{ chose_ary.join(' ') }}//讓chose_ary每個值的間隔加入空白並渲染


    5.radio 單選框
        checkbox與radio差別在於radio只能選擇一個，當你的v-model綁定同一個資料路徑時，選擇其中一個選項，另一個就會取消選擇
        所以回傳到資料的值只會有一個，我們直接看範例:

        data(){
            return{
                chose:'',//value為字串
            }
        }

        <input type="checkbox" value="標籤一" v-model="chose">//這邊value不需要用v-bind
        <input type="checkbox" value="標籤二" v-model="chose">
        <input type="checkbox" value="標籤三" v-model="chose">
        //三個綁定同一個資料路徑

        {{ chose }}//當我選擇標籤一，那其他被選擇的選項就會消失。接著當我在選擇標籤二，那原本選擇的標籤一會在消失，chose的值會改為標籤二

    6.select 單選
        select雖底下有很多的option，但v-model是綁在select上的。
        接著每個option都有各自的value。
        當select選擇option時，value會傳到資料庫中
        範例:

            data(){
                return{
                    chose:'',//value為字串
                }
            }

            <select v-model="chose">
                <option value="三民區s">三民區</option>
                <option value="小港區s">小港區</option>
                <option value="琴雅區s">琴雅區</option>
            </select>

            //當使用者點選三民區時，value三民區s會傳送到chose內
        
        select搭配v-for:

            data(){
                return{
                    data:[
                        {
                            name:'小明'
                        },
                        {
                            name:'杰倫'
                        },
                    ]
                }
            }

            <select v-model="chose">
                <option v-for="iteam in data" :key="iteam.name" :value="iteam.name">{{ iteam.name }}</option>//這邊注意若是沒有加上value，那麼回傳的值會是option內的文字。
            </select>
        
        補充:在select使用v-model時，因為資料原先是空字串，所以若是不選擇時。預設的select是空值。若是要顯示預設文字，那就新增一筆option標籤 並新增value的屬性
        //注意這邊的value是原生而非v-bind的
        //同時若是這個預設文字只要純顯示而非可以點選，就在這個option當中加入disable屬性即可
        範例:
        <option value="" disabled >請選擇人名</option>
        //value空值即可


    7.select多選
        select多選其實跟checkbox很像，基本上差別不大，只是顯示的方式不同而已。
        以下是用範例進行解說

        data(){
                return{
                    chose_ary:[],//為陣列形式
                }
        }


        <select v-model="chose_ary" multiple>//只需要加上multiple即可
            <option value="三民區">三民區</option>
            <option value="小港區">小港區</option>
            <option value="琴雅區">琴雅區</option>
        </select>


        {{ chose_ary }}
        //顯示為一個[]，當選擇三民區 會呈現["三民區"]。
        //再點選小港區 顯示["三民區","小港區"]。依此類推



ol.v-on
    v-on雖然可以觸發資料更動，但大部分比較少會使用到。多數情況都是與methos做綁定，透過methos再來更動data。
    v-on跟v-bind一樣都有縮寫形式，但兩者的縮寫形式是不同的
    v-on的縮寫形式是"@"
    範例:
    <button type="button" v-on:click="function"><button> 原先
    <button type="button" @click="function"><button> 縮寫


    1.使用代入參數的方法決定哪個布林值要轉換:
        在還未學習到這個方式前，我個人轉換的方式如下:
            change(){
                this.isShow = false
            }
            or
            change(){
                this.data.box = this.data.box ? false : true;
            }
        但其實可以使用代入參數的方法就不需要建立如此多的methods了
        範例:
            change(key){
                this[key] = !this[key];
                //邏輯就是讓代入資料路徑代入key，所以就是變成 this.[資料路徑]
                //而這個this[資料路徑]等同於this.資料路徑 也是其中一種物件屬性的指定方法
                //也就是說假設上面的key的值若原本是false，那就改為相反的。false的相反就是true。反之，true的相反是false。 
            }

    2.v-on綁定原生DOM事件:
        其實v-on:click就是綁定原生的事件。
        click本身就是原生的事件
        addEventListener('click',function,同步與否)
        下面會介紹搭配vue使用的事件用法

        submit事件
        submit事件是當form表單符合的條件後就會觸發
        範例:

        <form v-on:submit.prevent="function">//這邊使用了.prevent的修飾符，這個修飾符的作用是取消本身預設的作用 form本身預設的作用就是submit

            <input type="text" v-model="name">//因為裡面只有一個input 若這一個input被寫入內容並離開焦點時 就等於符合了條件
            <button>送出</button>//button若是不加上type原先就有submit的功效。然後因為是在form內，所以當form綁定了function，裡面的button也會綁定

        </form> 

        動態事件:
        v-on可使用動態綁定。何謂動態綁定?你可以依照資料庫的資料決定你的標籤要綁定哪一種事件
        範例:

        data(){
            event:'click'
        }
        method:{
            sayhi(){
                console.log('哈囉')
            }
        }

        <button type="button" @[event]="sayhi">送出</button>
        //通過修改event的資料，可以改變觸發的事件
        //不過在實戰中比較少用到這個動態事件


        動態物件的方法:
        除了多個 v-on外
        還可以使用動態物件的方法在同一個標籤綁定多個事件
        範例:
        <button type="button" @="{

            mousedown:function, //mousedown 為按下觸發事件
            mouseup: change,  //mouseup 為放開觸發事件
            事件:function,

        }">送出</button>
        //使用這個方法要注意，這個方法沒有辦法代入參數


    v-on DOM事件處理技巧:
        在原生JS內，只要觸發事件，事件都會回傳資料
            function(e){
                console.log(e);//回傳的資料
            }
        //在這裡面有包含你點擊的座標等等資料
        vue很多事件若在原生JS實現的話，內都要運用這些資料才能處理。
        而今天這邊要介紹如何使用這些資料

        若function有參數
        倘若我們function有參數，但又需要接收回傳的資料時該怎麼做?
        範例:
            function click(iteam,e){
                console.log(iteam,e);
            }

        <button type="button" v-on:click="click('代入的參數',$event)">按下</button>//只要在參數後加上$event 那這個就會是e的參數

        取得原生input的內容:

            function get(e){
                let value = e.target.value;//原生的取得value的寫法
            }
            <input type="text" @change="get">//注意，這邊是沒有綁定v-model的。如此當失去焦點後，get這個function就可以取到input內使用者輸入的資料

        監聽案件事件:

        function up(e){
            let code = e.keyCode;//keyCode是使用者按下的數字對應號碼
        }


        <input type="text" @keyup="up">//因為使用keyup，所以在每一次使用者按下按鍵時我們都能取得使用者按下的按鍵對應的號碼



ol.修飾符(modifiers)
    修飾符基本上來說就是扶助指令運作，用於v-model or v-on上
    那修飾符的位置都是在指令的後方
    範例:v-model.xxx="" //xxx為修飾符放置位置

    1.v-model修飾符
        首先我們先介紹v-model
        v-model修飾符有三個 lazy(延遲),number(純數值),trim(修剪)
        備註:這邊在使用修飾符之前記得要開啟vetools

        1.lazy 延遲:
            綁定lazy的用處是不會馬上綁定，當失去焦點時才會綁定。就有些類似原生的input、與change的差別
            也就是說當加入了lazy，input的值在修改時並不會馬上更動資料庫的資料，而是等到失去焦點時才會套用到資料庫的資料當中
            //失去焦點的意思是指當你點到非這個input時，那就是失去焦點。點到input的時就是在焦點內。
            範例:
                <input type="text" v-model.lazy="data">

        2.number 數值
            這個修飾符的功用是讓輸入框輸入的資料轉為數字而非是字串，常用於取得計算資料中
            //注意:使用這個功能並非就是強制使用者只能輸入數字，使用者輸入字串依然可以輸入。所以可以搭配input type的number使用
            範例:
                <input type="number" v-model.number="data">
        
        3.trim
            有時候當我們需要取得值不能有空白時，那就可以使用trim。trim可以將兩側的所有空白值都消除後才將資料傳送至資料庫。
            //注意 只有兩邊的空白消除，若字串中間有空白還是會有空白內容
            //原生strings.trim()的效果

    2.v-on修飾符

        按鍵修飾符:

            別名修飾:
            所謂別名修飾就是當按下特定的按鍵時才會觸發
            常用的共有這幾個種類:
            .enter, .tab, .delete, .esc, .space, .up, .down,
            範例:
            <input type="text" @keyup.enter="function">


            組合觸發:
            當我們需要有多個按鍵組合起來才能觸發時，就在多加一個修飾符
            <input type="text" @keyup.shift.enter="function">
            
            特定案件:
            其實與別名差不多，別名是常見的按鍵，那特定就是指定的鍵盤按鍵
            <input type="text" @keyup.h="function">//按下鍵盤上的h才會觸發


        滑鼠修飾符:
            當我們使用click事件按下滑鼠時，都會觸發click事件，但若是只要特定鍵，如右鍵有反應，那就需要搭配相關修飾符
            //這就類似原生contextmenu事件


            .left//左鍵觸發
            .right//右鍵觸發
            .middle//中鍵觸發

            範例:
                <div @click.right="function"><div>

        事件修飾符:
            事件修飾符最常出現的就是.prevent 這個就是原生function內的e.defaultPrevent() 取消預設事件
            很多事件都有屬於它原本的預設事件，e.defaultPrevent()就是阻止預設事件觸發的代碼
            從這方面我們就可以知道事件修飾符的功用了，以下開始介紹:

            .stop 調用e.stopPropagation 這個是阻止冒泡(防止向外尋找)
            //這個也就是說當不會觸發點選的區塊父層的事件

            .capture 事件由外而內查找 稱捕獲/捕捉

            .self 只會觸發自己的事件 也就是不會向內也不會向外觸發子父層的事件

            .once 只觸發一次回調 白話說就是只會觸發一次
            //原生的 function once(){}
            //buttonEl.addEventListener('click', function (e) {
                console.log('綁定一次');
            },{once: true});

