
JS前置觀念

---語法糖---:
語法糖只是讓程式碼看起來更簡潔，與原先並不會有使用上的差異。
在物件使用屬性都需要加分號:
但在ES6以後
若是function則直接輸入function的呈述式即可
範例:
let d ='d'
let obj = {
    a:'a',
    fn(){
        console.log('i')
    },
    b:'b',
    d,
}

除了function外，物件也可以直接代入，那麼屬性名稱就等於變數名稱，屬性值等於變數值

陣列串接---
以往來說會是 c = a陣列.concat(b陣列)
但ES6可以使用更省事的方法

C陣列 =[...a陣列,...b陣列]//...的方法是將陣列內的物件取出並排列
若沒有使用...的話，c陣列會是包住a陣列及b陣列

同時物件也可以用此方法新增

let a = {
    a:'a',
    b:'b',
}

let c ={
    ...a
}

//類陣列轉為純陣列也可以使用相同方法


---預設值---
現在參數也可以帶入預設值，假設今天有兩個參數，但使用者只代入一個那很有可能會出現bug
let fn = (a,b)=>{
    return a + b
};

fn(1,2) //3
fn(1) //NaN

傳統的方法避免的方法是
let fn = (a,b)=>{
    if(!b){b=2}
    return a + b
};

現在只需要使用預設值就可以避免錯誤

let fn = (a,b = 2)=>{
    return a + b
};


---this指向---

simple call

範例:
var someone = '全域';
function callsomeone(){
    console.log(this.someone);
};

callsomeone();//這個就叫做simple call 當前面沒有任何物件，就叫做simple call 又稱為簡易呼叫

而this的指向跟怎麼定義它沒有關聯而是呼叫的方法。假設使用simple call 就是呼叫全域
但若是使用object.callsomeone(),那就會指向前面的object內的內容。


var obj = {
    someone:'物件',
    callsomeone //將上面宣告的函式放進來
};

obj.callsomeone()//顯示物件


物件內的物件呼叫

var obj2 = {
    someone:'物件外',
    callsomeone //將上面宣告的函式放進來
    obj = {
        someone:'物件內',
        callsomeone //將上面宣告的函式放進來
    };
};

obj2.obj.callsomeone()//顯示物件內


常見陷阱


var obj = {
    someone:'物件',
    fn(){
        callsomeone();//它其實也算simple call 但平常並不會這樣使用
        //注意這裡，callsomeone前面並沒有任何物件
    }
};

obj.fn()//顯示全域


var obj = {
    someone:'物件4',
    fn(){
        setTimeout(()=>{
            console.log(this.someone)
        });
    },
};

obj.fn()//顯示全域 原因是setTimeout是在全域下執行而非object

補充:若是在事件觸發後，this通常代表觸發的元素本身
總結:this的指向跟調用(呼叫)的方法有關



---箭頭函式---

特點:除了語法糖外，特點就是它沒有自己的this
範例:
let obj = {
    callName:function(){
        console.log(this);//顯示物件本身
        setTimeout(()=>{
            console.log(this)//在傳統函式中會指向window，但若是使用箭頭函式則會跟著父層指向相同，在這個範例中也就是指向物件。
        }),
    }
}

obj.callName();


常見陷阱
let name = 全域;
let obj = {
    name:'小明',
    callName:()=>{
        console.log(name);
    }
}

obj.callName()//顯示全域。與傳統函式不同，前面說到箭頭函式會跟著父層指向相同。但在這個範例中obj內的callname外層並沒有函式，準確地來說它的外層函式就是全域，所以這個this就指向全域。


let name = 全域;
let obj = {
    name:'小明',
    callMe(){
        let callName = ()=>{
            console.log(this.name);
        };
        callName();
    },
};

obj.callMe()//顯示小明 因為在callname外層的函式是傳統函式，也就是指向物件本身，而箭頭函式則是跟隨外層函式來定義this。理所當然地也就跟著callMe的this定義。




---元件結構(關注點分離/MVVM)---
所謂元件結構就是將一個功能所運用到的所有內容都放在一個物件中，包含函式、儲存的資料等
依所需情況調用及觸發，每一個屬性都各自獨立但卻又相關，所以稱為關注點分離。
基本的元件結構有:
1.資料
2.方法、觸發器
3.生命週期


const click ={
    data:[],
    function(){

    },//若是要渲染HTML結構，盡量在一個function內
    init(){//稱為生命週期，一開始載入後所要執行的函式
        this.function
    }
}


範例:
const click ={
    data:[],
    fn(){
        console.log('安安你好')
    },
    init(){//稱為生命週期，一開始載入後所要執行的函式，通常是開發者自訂義
        this.fn();
    },
}
click.init()


---物件、陣列、函式傳參考---

在我們創立一個物件的時候，其實並非是像純值(如字串、布林)一樣將值賦予到變數上，而是將物件的位置傳給變數。

當我們新增一個物件就相當於在網頁的儲存區建立物件。而當我們要取用物件時就會自動導向物件的路徑。
好比賦予變數物件，讓我們從以下範例解釋。

let a = {x:1};
//在這操作中瀏覽器共做了兩件事
1.在瀏覽器的儲存區中新增{x:1}的物件
2.將儲存區的物件路徑賦予到a

所以當我們使用console.log(a)時，其實是從a這個路徑瀏覽{x:1}這個物件。
由此可知，當我們同時賦予兩個變數一樣的物件時，他們的路徑都是一樣的，其中一個物件屬性及值更動，另一個也會同步。

let a= {x:1};

let b = a;

b.x = '2';

console.log(a.x)//顯示2

須知注意:
但是我們得注意，當我們又新增了一個{}時，就等同於又新增了一個路徑，就算裡面內容相同也並非是同一個路徑。
範例:

let a = {x:1};

let b = {x:1};

console.log(a===b)//回傳false


淺深層複製

當我們要複製物件內容但又不共用同一個參考路徑時該怎麼做呢?
有兩個方法，淺層及深層。

淺層:
淺層就是複製物件內的值與屬性，但屬性的值內若有物件，那這個物件還是共用同個路徑的。
let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = Object.assign({},a);//方法一
let c = {...a}//方法二

//按照上面的範例來說，a跟b還是共用同一個x物件路徑


深層:
深層拷貝就不會有共用路徑的問題，而是會創造一個新的物件
原理很簡單，就是將物件內的所有內容都轉為字串，再從字串轉為物件。


let a = {
    y:'1',
    x:{
        z:1
    }
};

let b = JSON.parse(JSON.stringify(a));



promise

promise 嚴格來說是為了解決非同步語法難以建構以及管理的問題。
簡單來說就是在所有資料都處理好以後，再接續執行下一步。
常用於AJAX，當處理完所有傳送及取得的程序以後，再來接續進行下一步的渲染等動作。
經典使用promise的AJAX處理套件為axios

promise會先建立一個建構式

const promise_Set = (status)=>{//套入狀態
    return new Promise(resolve,reject)=>{
        setTimeout(()=>{//讓此程式碼最後執行
            if(status){//當狀態為true時
                resolve('成功')//resolve的參數代入成功
            }else{
                reject('失敗')//reject的參數代入失敗
            }
        })
    }
}

promise_Set(true);//狀態套入
    .then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
    })
    .catch((rej)=>{
        console.log(rej)//同上會是reject的('失敗')
    })


promise串接
promise_Set(true)
.then((res)=>{//這裡的res參數，就會是resolve內的('成功')
        console.log(res)
        return promise_Set(true)//當在此使用return時，下一個.then/.catch就會是此promise_Set(true)所回傳的結果
    })
.then((res)=>{
    console.log(res);
})

元件中使用promise

const a = {
    data:{}
    init(){//這邊若是要用this需要使用傳統函式，因為箭頭函式this是隨著父層函式的this而定義
        promise_Set(true)
        .then(res=>{
            this.data.res = res;//在data元件中新增res的屬性及值
        })
        .catch((rej)=>{
            alert('傳送失敗');
        })
    }
}

a.init();



使用axios搭配promise

axios.get('url')//url代表連接網址
    .then((res)=>{
        console.log(res)//res回傳的資料
    }) //axios內建就有promise所以可以不用建構直接使用
    .catch((rej)=>{
        console.log(rej.response)//回傳失敗的資料
        console.log('串接失敗')
    })

post方法補充: axios.post('url',{傳送的內容});



---ES模組---

ES步驟:

1.於模組化的script上加上type="module"

2.匯出匯入觀念
匯入跟匯出有很大的關連，所以我們先說明匯出。

匯出(js)//僅在js進行

匯出又分成預設跟具名匯出

預設匯出: export default
//每個檔案只能有一個


具名匯出: export const xxx = ...
//每個檔案有多個
而匯出可以同時匯出具名及預設



匯入(html,js)//在html or js進行
既然有預設匯出，自然也又預設匯入及具名匯入

預設匯入 import 自訂名稱 from 檔案

具名匯入{具名名稱} from 檔案


匯出入方法

匯出用法
1.新建個匯出JS檔案

2.填上匯出程式碼
export default {//默認
    ...程式碼
}

export const abc{//具名
    ...程式碼
}

匯入用法

1.在要匯入的檔案中導入

import fn from './...路徑'//默認

import{abc} from './all.js'


此時fn就等於你寫在匯入JS檔案內的那一個function or obj or ary or 變數

2.使用
接下來就看你是匯入甚麼，就照原先的方法使用即可。



匯入有兩種方式:
單一匯入、全部匯入

比較建議單一匯入，因為全部匯入錯誤難以發現
單一匯入就是個別匯入
全部顧名思義就是不管有多少個匯出，一次接受一次匯入


單一:

inport {a,b} from '路徑'
//匯入a及b匯出


全部:

import * as all from '路徑'
//as 是賦予到一個變數的名稱上 all就是那個物件的名稱


sideEffect.js(沒有包含匯出的檔案):
也就是沒有使用export的內容，其實也可以進行匯入

inport '路徑' //直接導入即可



實戰:

先說明每一個 type="module"的作用域是各自獨立的。
也就是說假設有兩個script都有綁type="module"並且有匯入。
但我在第一個匯入的檔案，在第二個是無法使用的


ESM
網路上找的到的CDN的網址上若有ESM字樣基本上都可以使用import的方式匯入

inport {} from 'CDN網址'

直接使用




觀念都理解了，正式進入vue的教學。

首先vue的概念就是對應元件結構
{
    data:[儲存的資料]
    render()//渲染HTML的function(事件觸發)
    init()//載入時所執行的動作(生命週期)
    //假設今天要使用這個元件結構，就從呼喊init這個function就會執行。
}

只是vue都幫你把以上的事情都做好了，基本上只需要在指定標籤加上指定屬性，vue就會幫你做渲染


vue 環境設置
於瀏覽器安裝vue開發者工具套件
網址:https://headwayapp.co/vue-js-devtools-changelog/timeline-and-api-166716
//注意一定要從這安裝beta版本，可能是設定問題正式版沒辦法使用。

在開發者工具中可以找到vue的介面
    介面左邊會有一個根元件，點選，右邊會有data的資料庫。
    後面開發的話都會以這個根元件為主，階梯式的呈現在介面上

載入vue cdn放在head內 //這邊要注意版本，目前教學為3

<script src="https://unpkg.com/vue@next"></script>



---第一課定義元件---
型態:
Vue.createApp({//定義元件 也就是vue的起手式，類似jq的$(doc).ready

  data(){
    return{
      //資料庫
    }
  }
}).mount('DOM')// 執行元件    
//這邊的mount是將這個元件給綁定到指定的DOM


範例及解說:
Vue.createApp({//使用vue時都會先使用createApp，上面有提到類似JQ的ready
  data() {//定義一個資料儲存區 需注意的點是這邊的data是一個函式，資料是用return的方式回傳。這個作法的用意是使用原生JS內件的proxy功能，讓物件內的其他函式可以使用this.屬性調用
    return {
      counter: 0,
      text: '這裡有一段文字123'
    }
  }
}).mount('#app')//到mount之前，元件及資料儲存的定義就已經完成，mount則是綁定DOM


---第二課完整vue定義及事件--- 

型態說明:

<div> {{value}} </div>//顯示123 這邊是輸入資料路徑。
簡單的說明一下資料路徑
當我們需要調用data()這個資料庫內的路徑時，data所回傳的就是一個物件，並不需要使用data.value的方式呼叫，因為當data()將{}回傳時，{}就已經是app這個物件內的值了。
總得來說就是只需要使用要調用時只需要使用return{}物件內的值就可以了。
假設你物件內的值是物件，你要取用物件內的物件，就使用原生js的物件呼叫方法即可。


<input type="buttom" v-on:click="click"> //當DOM要觸發methods裡面的方法時，於標籤內輸入v-on:觸發事件="function" ex.這邊不需要再加個中括號了()

const app = {
    data(){//資料儲存區 ex.這邊一定要是函式
        return{
            value:'123'//通過{{屬性}}，可以將值給渲染到瀏覽器上
        }
    }
    created(){生命週期 更改data內容
        this.value = '456'//這邊之所以抓地到data的值是因為使用了return，return後的內容就會被proxy攔截。簡單來說就是return後內容父層抓地到
    }
    methods:{//方法(事件觸發) ex.會是一個物件

        click(){
            console.log('安安');
        }        
    }
}

事件型態:
HTML
<div v-on:事件="function名稱">按鈕</div>
//因為已經綁定在區塊中了，所以不需要再使用物件方法呼叫
methods.click (X)
click (O)//不需要加入()

第三課 雙向綁定

v-model 綁定到資料輸入區並與其同步，只要資料輸入區改變or v-model的內容改變，兩者都會同步 (綁定一)

當定義一個元件以後，若是要將input取得的資料輸入進資料庫需要使用v-model
相當於原生.value /JQ.val()的概念。

型態:
HTML
<input v-model="資料庫物件名稱.屬性名稱">//已經綁定在區塊內，所以就直接使用資料路徑即可



v-bind: 綁定輸出到HTML屬性上 (綁定二)
v-bind可以資料酷的輸出到指定的HTML屬性上
型態:
HTML
<img bind:src="資料庫名稱.屬性名稱"

稱為雙向綁定的原因是兩者已經同步，當有一方改變，另一方也會同步改變。



第四課 導入外部資料進資料區

說明:

let obj = {//外部資料 不管外部資料是甚麼形式。陣列 or 物件等都一樣可以導入
    a:123,

}


const = add{
    data(){
        return{
            data:{
                
            }
        }
    },
    created(){//當我們要使用外部資料進行渲染時，就在生命週期這邊導入外部資料，這邊在一開始載入vue的時候就會執行
        this.data = obj//如此在載入vue時，外部的資料就會導入到指定的路徑
        //這邊要注意this本身就已經代表data，所以這個data是return物件內的data屬性喔
    }
    method:{

    }
}

Vue.createApp(add).mount('#id')


---第五課 將資料傳入資料庫---
因為v-model的特性是雙向綁定，所以假設我們每一次觸發事件都要新增一筆不一樣的資料要怎麼處理呢?
範例解說如下:

 <div id="app">
        帳號:
        <input type="text" v-model="temp.account">
        <!-- v-model有個特點 假設指定路徑內沒有該屬性，那會自動新增這個屬性 -->
        <br>
        密碼:
        <input type="text" v-model="temp.password">
        <br>
        <button type="button" v-on:click="add_userdata">送出</button>
        <!-- 這邊type要使用button 否則預設定義是submit -->
        導入的帳密:{{temp.account}},{{temp.password}}
        <br>
        userdata內容:{{userdata}}
    </div>
    <script>
       Vue.createApp({
            data(){
                return{
                    userdata:[],
                    temp:{}
                }
            },
            created(){
                this.userdata = JSON.parse(localStorage.getItem('user'));//從local端取得資料
            },
            methods:{
                add_userdata(){
                    this.temp.id = new Date().getTime();//此行目的產生唯一性id 從這邊也可以有v-model的特效，物件內沒該屬性會自動新增 就跟原生JS一樣
                    this.userdata.push(this.temp);//將目前temp的內容上傳至userdata這個陣列內
                    this.temp = {};//清空
                    this.update();//輸入至local端
                },
                update(){
                    // localStorage.setItem('user',JSON.stringify(this.userdata))
                    localStorage.setItem('user',JSON.stringify(this.userdata))
                }
            },
        }).mount('#app');
        //順便提一下原生的方法 取得DOM.value > 輸入資料庫and localstorage > 用innerHTML渲染網頁 
    </script>


---第五課使用v-for將多筆資料渲染到網頁---

v-for這個屬性的功能類似使用for迴圈累積文字並渲染到網頁上，只是這個操作更直覺簡潔。
型態:
指定DOM上 v-for="自訂義名稱 in 資料路徑(陣列或物件)"
//這個就類似for in的方法 但還是有些不同
//v-for的原理是這樣的，它會掃過資料路徑的物件或陣列
//接著使用者就可以使用{{自訂義名稱.屬性}}(自訂義名稱代表物件或陣列內的值)將內容給呈現到畫面上
//使用者這邊只要輸入一次即可，當你在HTML的標籤上輸入一次{{}}，就會自動將資料路徑內的所有值都呈現在畫面上


多說無益，直接看範例:

先看script code
  <ul id="app">
        <li>
            <img src="./根元件.png" alt="" style="width: 50px;border: 1px solid;">
            <p>商品一</p>
        </li>
        <li v-for="i in products" :key="i.id" >
            <!-- 
                型態:v-for="自訂義名稱 in 資料路徑(物件/陣列) v-for會自動讀取指定路徑的所有內容"
                接著v-for要放到想要複製的區塊上，只要放上來子DOM也會一同執行for
                這邊補充key用意，是要讓每個渲染出來的區塊有唯一性，方便之後操作
            -->
            <img v-bind:src="i.url" alt="商品圖" style="width: 50px;border: 1px solid;">
            <!-- 因為會v-for會一一的複製指定DOM，所以子內容的v-bind也會跟著一一改變跟渲染 -->
            <p>{{i.name}}</p>
            <!-- 文字同上說明 -->
        </li>
    </ul>

    <script>
      
        const products = [//導入的資料
            {
                id:'1',
                name:'商品二',
                url:'https://chiyum.github.io/myPage/img/formalLogoNb.png'
            },
            {
                id:'2',
                name:'商品三',
                url:'https://chiyum.github.io/holdkibor/img/logo.png'
            },
        ];

        Vue.createApp({
            data(){
                return{
                    products:[],//先建立個空物件，等啟動後導入資料
                };
            },
            created(){
                this.products = products;//載入時導入外部資料
            },
            method:{

            }
        }).mount('#app');//綁定區塊

        //輸入完往HTML繼續

    </script>


補充:會使用key="iteam.id"是要補上唯一值，這在後面章節會介紹。
